Nsamp = nrow(TryGiR$Forward)#
thin = seq(from = floor(Nsamp / 5), to = Nsamp, length.out = 500)#
par(mfrow=c(2,5))#
matplot(TryGiR$delta[thin, ],type = 'l', col = 1:2, lty = 1, xlab = "iter", ylab = "delta")#
matplot(cbind(TryGiR$entropyC1[thin,1],TryGiR$entropyC2[thin,1]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(topic-IP)")#
matplot(cbind(TryGiR$entropyC1[thin,2],TryGiR$entropyC2[thin,2]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(topic-token overall)")#
matplot(cbind(TryGiR$entropyZ1[thin],TryGiR$entropyZ2[thin]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(word-token)")#
matplot(cbind(TryGiR$Zstat1[thin],TryGiR$Zstat2[thin]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "mean(entropy(topic-token[[d]]))")
Nsamp = nrow(TryGiR$Forward)#
thin = seq(from = floor(Nsamp / 5), to = Nsamp, length.out = 500)#
par(mfrow = c(3, 3))#
for (p in 1:9){#
matplot(cbind(TryGiR$Forward[thin,p], TryGiR$Backward[thin,p]), type = 'l', col = 1:2, lty = 1, main = colnames(TryGiR$Forward)[p], xlab = 'iter', ylab ='')#
}
colMeans(TryGiR$accept.rate)
head(TryGiR$delta)
cor(TryGiR$delta)
par(mfrow=c(2,5))#
matplot(TryGiR$delta[thin, ],type = 'l', col = 1:2, lty = 1, xlab = "iter", ylab = "delta")#
matplot(cbind(TryGiR$entropyC1[thin,1],TryGiR$entropyC2[thin,1]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(topic-IP)")#
matplot(cbind(TryGiR$entropyC1[thin,2],TryGiR$entropyC2[thin,2]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(topic-token overall)")#
matplot(cbind(TryGiR$entropyZ1[thin],TryGiR$entropyZ2[thin]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(word-token)")#
matplot(cbind(TryGiR$Zstat1[thin],TryGiR$Zstat2[thin]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "mean(entropy(topic-token[[d]]))")#
matplot(TryGiR$delta[thin, ],type = 'l', col = 2:1, lty = 1, xlab = "iter", ylab = "delta")#
matplot(cbind(TryGiR$entropyC2[thin,1],TryGiR$entropyC1[thin,1]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(topic-IP)")#
matplot(cbind(TryGiR$entropyC2[thin,2],TryGiR$entropyC1[thin,2]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(topic-token overall)")#
matplot(cbind(TryGiR$entropyZ2[thin],TryGiR$entropyZ1[thin]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(word-token)")#
matplot(cbind(TryGiR$Zstat2[thin],TryGiR$Zstat1[thin]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "mean(entropy(topic-token[[d]]))")
library(IPTM)#
TryGiR<- GiR(5*10^3, nDocs = 20, node = 1:4, prior.delta = c(4, 8), niters = c(1, 1, 1, 50, 0, 1), prior.b.mean = c(-2, rep(0, 6)), sigma_Q = c(0.25, 2), seed = 1)
Nsamp = nrow(TryGiR$Forward)#
thin = seq(from = floor(Nsamp / 5), to = Nsamp, length.out = 500)#
par(mfrow=c(2,5))#
matplot(TryGiR$delta[thin, ],type = 'l', col = 1:2, lty = 1, xlab = "iter", ylab = "delta")#
matplot(cbind(TryGiR$entropyC1[thin,1],TryGiR$entropyC2[thin,1]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(topic-IP)")#
matplot(cbind(TryGiR$entropyC1[thin,2],TryGiR$entropyC2[thin,2]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(topic-token overall)")#
matplot(cbind(TryGiR$entropyZ1[thin],TryGiR$entropyZ2[thin]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(word-token)")#
matplot(cbind(TryGiR$Zstat1[thin],TryGiR$Zstat2[thin]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "mean(entropy(topic-token[[d]]))")#
matplot(TryGiR$delta[thin, ],type = 'l', col = 2:1, lty = 1, xlab = "iter", ylab = "delta")#
matplot(cbind(TryGiR$entropyC2[thin,1],TryGiR$entropyC1[thin,1]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(topic-IP)")#
matplot(cbind(TryGiR$entropyC2[thin,2],TryGiR$entropyC1[thin,2]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(topic-token overall)")#
matplot(cbind(TryGiR$entropyZ2[thin],TryGiR$entropyZ1[thin]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(word-token)")#
matplot(cbind(TryGiR$Zstat2[thin],TryGiR$Zstat1[thin]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "mean(entropy(topic-token[[d]]))")
colMeans(TryGiR$accept.rate)
(TryGiR$accept.rate)
for (p in 1:14) {#
	matplot(cbind(TryGiR$b1[thin ,p], TryGiR$b2[thin,p]),type = 'l', col = 1:2, lty = 1)#
}
Nsamp = nrow(TryGiR$Forward)#
thin = seq(from = floor(Nsamp / 5), to = Nsamp, length.out = 500)#
par(mfrow = c(3, 3))#
for (p in 1:9){#
matplot(cbind(TryGiR$Forward[thin,p], TryGiR$Backward[thin,p]), type = 'l', col = 1:2, lty = 1, main = colnames(TryGiR$Forward)[p], xlab = 'iter', ylab ='')#
}
Nsamp = nrow(TryGiR$Forward)#
thin = seq(from = floor(Nsamp / 5), to = Nsamp, length.out = 500)#
par(mfrow = c(3, 7))#
for (p in 1:21){#
matplot(cbind(TryGiR$Forward[thin,p], TryGiR$Backward[thin,p]), type = 'l', col = 1:2, lty = 1, main = colnames(TryGiR$Forward)[p], xlab = 'iter', ylab ='')#
}
library(IPTM)#
library(mvtnorm)#
library(MCMCpack)#
nDocs = 10#
node = 1:4#
vocabulary = c("hi", "hello", "fine", "bye", "what")#
nIP = 2#
K = 4#
nwords = 4#
alpha = 2#
mvec = rep(1/4, 4)#
betas = 2#
nvec = rep(1/5, 5)#
prior.b.mean = c(-2.5, rep(0, 6))#
prior.b.var =  diag(7)#
prior.delta = c(4, 8)#
sigma_Q = c(0.25, 2)#
niters = c(1, 50, 10, 0, 1)#
netstat = c("intercept", "dyadic")#
P = 1 * ("intercept" %in% netstat) + 3 * (2 * ("dyadic" %in% netstat) + 4 * ("triadic" %in% netstat) + 2 *("degree" %in% netstat))#
b = lapply(1L:nIP, function(IP) {#
    c(rmvnorm(1,  c(-2.5, rep(0, 6)),  diag(7)))#
  })#
delta = rgamma(1, 4, 8)#
currentC = sample(1L:nIP, K, replace = TRUE)	 #
base.data = GenerateDocs(30, node, vocabulary, nIP, K, nwords, alpha, mvec, betas, nvec, b, delta, currentC, netstat, base.edge = list(),  base.text = list(), base = TRUE) #
base.edge = base.data$edge	   #
base.text = base.data$text#
TryGiR<- GiR(5*10^3, nDocs, node, vocabulary, nIP, K, nwords, alpha, mvec, betas, nvec, #
               prior.b.mean, prior.b.var, prior.delta, sigma_Q, niters, netstat, base.edge, base.text, seed = 12345)
Nsamp = nrow(TryGiR$Forward)#
thin = seq(from = floor(Nsamp / 5), to = Nsamp, length.out = 500)#
par(mfrow=c(1,5))#
matplot(TryGiR$delta[thin, ],type = 'l', col = 1:2, lty = 1, xlab = "iter", ylab = "delta")#
matplot(cbind(TryGiR$entropyC1[thin,1],TryGiR$entropyC2[thin,1]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(topic-IP)")#
matplot(cbind(TryGiR$entropyC1[thin,2],TryGiR$entropyC2[thin,2]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(topic-token overall)")#
matplot(cbind(TryGiR$entropyZ1[thin],TryGiR$entropyZ2[thin]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "entropy(word-token)")#
matplot(cbind(TryGiR$Zstat1[thin],TryGiR$Zstat2[thin]) ,type = 'l', col = 1:2, lty =1, xlab = "iter", ylab = "mean(entropy(topic-token[[d]]))")
Nsamp = nrow(TryGiR$Forward)#
thin = seq(from = floor(Nsamp / 5), to = Nsamp, length.out = 500)#
par(mfrow = c(3, 7))#
for (p in 1:21){#
matplot(cbind(TryGiR$Forward[thin,p], TryGiR$Backward[thin,p]), type = 'l', col = 1:2, lty = 1, main = colnames(TryGiR$Forward)[p], xlab = 'iter', ylab ='')#
}
rexp(1, 0)
load("/Users/bomin8319/Desktop/DLFM/UNfit/DLFM_NA.RData")#
attach(UN_NA)#
library(ggplot2)#
library(MCMCpack)#
library(reshape2)#
library(gridExtra)#
library(ggrepel)
years = c(1983:2014)
colors = sort(rownames(U[[32]]))#
	thetanew = sapply(1:32, function(t){colMeans(UN_NA$theta[[t]])})#
	data3 = data.frame(years = years, theta = t(thetanew))
head(data3)
orders = sapply(1:23, function(n){which(colors[n]== colnames(data3)[-1])})
data3 = data3[,orders]
head(data3)
thetanew = t(sapply(1:32, function(t){colMeans(UN_NA$theta[[t]])}))
head(thetanew)
thetanew = t(sapply(1:32, function(t){colMeans(UN_NA$theta[[t]])}))#
	orders = sapply(1:23, function(n){which(colors[n]== rownames(U[[32]]))})
orders
thetanew = thetanew[,orders]
head(thetanew)
data3 = data.frame(years = years, theta = thetanew)
colnames(data3)[-1] = colors
head(data3)
data3new = melt(data3, id = "years")
colnames(data3new)[3] = "theta"
f <- ggplot(data3new, aes(years, theta, colour = variable, label = variable))
f + geom_line() + scale_x_continuous(breaks=number_ticks(8)) + scale_colour_discrete(name = "countries")
number_ticks <- function(n) {function(limits) pretty(limits, n)}
f + geom_line() + scale_x_continuous(breaks=number_ticks(8)) + scale_colour_discrete(name = "countries")
f + geom_line() + scale_x_continuous(breaks=number_ticks(8)) + scale_colour_discrete(name = "countries")+ geom_text()
data3new[data3new$year==2014,]
data3new[data3new$year==2014,3]
f + geom_line() + scale_x_continuous(breaks=number_ticks(8)) + scale_colour_discrete(name = "countries")+ annotate("text", x = rep(2014, 23), y = data3new[data3new$year==2014,3], label = colors)
f + geom_line() + scale_x_continuous(breaks=number_ticks(8)) + scale_colour_discrete(name = "countries")+ annotate("text", x = rep(2014, 23), y = data3new[data3new$year==2014,3], label = colors, colour = colors)
f + geom_line() + scale_x_continuous(breaks=number_ticks(8)) + scale_colour_discrete(name = "countries")+ annotate("text", x = rep(2014, 23), y = data3new[data3new$year==2014,3], label = colors, colour = factor(colors))
f + geom_line() + scale_x_continuous(breaks=number_ticks(8)) + scale_colour_discrete(name = "countries")+ annotate("text", x = rep(2014, 23), y = data3new[data3new$year==2014,3], label = colors, aes(color = colors))
f + geom_line() + scale_x_continuous(breaks=number_ticks(8)) + scale_colour_discrete(name = "countries")+ annotate("text", x = rep(2014, 23), y = data3new[data3new$year==2014,3], label = colors, color = factor(1:23))
f + geom_line() + scale_x_continuous(breaks=number_ticks(8)) + scale_colour_discrete(name = "countries")+ annotate("text", x = rep(2014, 23), y = data3new[data3new$year==2014,3], label = colors, fill = factor(1:23))
f + geom_line() + scale_x_continuous(breaks=number_ticks(8)) + scale_colour_discrete(name = "countries")+ geom_text(aes(x = rep(2014, 23), y = data3new[data3new$year==2014,3], label = colors, colour = colors))
f + geom_line() + scale_x_continuous(breaks=number_ticks(8)) + scale_colour_discrete(name = "countries")+ geom_text(aes(x = rep(2014, 23), y = data3new[data3new$year==2014,3], label = colors))
eom_text(x = rep(2014, 23), y = data3new[data3new$year==2014,3], label = colors))
f + geom_line() + scale_x_continuous(breaks=number_ticks(8)) + scale_colour_discrete(name = "countries")+ geom_text(x = rep(2014, 23), y = data3new[data3new$year==2014,3], label = colors))
f + geom_line() + scale_x_continuous(breaks=number_ticks(8)) + scale_colour_discrete(name = "countries")+ annotate("text", x = rep(2014, 23), y = data3new[data3new$year==2014,3], label = colors, fill = factor(1:23))
f + geom_line() + scale_x_continuous(breaks=number_ticks(8)) + scale_colour_discrete(name = "countries")
load("/Users/bomin8319/Desktop/DLFM/UNfit/UNdatafull.RData")
load(DLFM)#
reduced <-which(dimnames(Y)[[2]] %in% c("USA", "CHN", "IND", "UKG", "FRN", "GFR", "TUR", "JPN", "ISR", "SYR", "LEB", "SUD", "IRN", "AUL", "PAK", "EGY", "AFG", "PRK", "RUS", "GRG", "UKR", "ROK", "IRQ"))#
#
#reduced <-which(dimnames(Y)[[2]] %in% c("USA", "CHN", "IND", "UKG", "FRN", "GFR", "TUR", "JPN", "ISR", "SYR", "LEB", "SUD", "IRN", "AUL", "PAK", "EGY"))#
Y = Y[, reduced, reduced]#
X = X[, reduced, reduced, 1:5]#
#
for(tp in 1:32){#
	diag(X[tp,,,2]) = 0#
}#
# not existing countries -> all missing values imputed using model (biased)#
avail1 = matrix(1, 32, 23)#
avail1[1:4, 21:23] = 0#
avail1[5:6, 21:22] = 0#
avail1[7, 21] = 0#
avail1[13:21, 9] = 0
50000/250
50000/200
50000/100
UN_NA = DLFM_NA(Y[1:32,,], X[1:32,,,1:5], R = 2, avail = avail1, burn = 40000, prescan = 10000, nscan = 50000, odens = 100, seed = 1)
attach(UNdatafull)#
library(FastGP)#
library(mvtnorm)#
library(fields)#
library(reshape)#
library(MCMCpack)
library(expm)
UN_NA = DLFM_NA(Y[1:32,,], X[1:32,,,1:5], R = 2, avail = avail1, burn = 40000, prescan = 10000, nscan = 50000, odens = 100, seed = 1)
UN_NA2 = DLFM_NA(Y[1:32,,], X[1:32,,,1], R = 2, avail = avail1, burn = 40000, prescan = 10000, nscan = 50000, odens = 100, seed = 1)
UN_NA1 = DLFM_NA(Y[1:32,,], X[1:32,,,1], R = 2, avail = avail1, burn = 15000, prescan = 5000, nscan = 30000, odens = 100, seed = 1)#
UN_NA2 = DLFM_NA(Y[1:32,,], X[1:32,,,1:2], R = 2, avail = avail1, burn = 15000, prescan = 5000, nscan = 30000, odens = 100, seed = 1)#
UN_NA3 = DLFM_NA(Y[1:32,,], X[1:32,,,1:3], R = 2, avail = avail1, burn = 15000, prescan = 5000, nscan = 30000, odens = 100, seed = 1)#
UN_NA4 = DLFM_NA(Y[1:32,,], X[1:32,,,1:4], R = 2, avail = avail1, burn = 15000, prescan = 5000, nscan = 30000, odens = 100, seed = 1)#
UN_NA5 = DLFM_NA(Y[1:32,,], X[1:32,,,1:5], R = 2, avail = avail1, burn = 15000, prescan = 5000, nscan = 30000, odens = 100, seed = 1)
names(UN_NA5)
UN_NA1 = DLFM_NA(Y[1:32,,], X[1:32,,,1], R = 2, avail = avail1, burn = 15000, prescan = 5000, nscan = 30000, odens = 100, seed = 1, plot = FALSE)#
UN_NA2 = DLFM_NA(Y[1:32,,], X[1:32,,,1:2], R = 2, avail = avail1, burn = 15000, prescan = 5000, nscan = 30000, odens = 100, seed = 1, plot = FALSE)#
UN_NA3 = DLFM_NA(Y[1:32,,], X[1:32,,,1:3], R = 2, avail = avail1, burn = 15000, prescan = 5000, nscan = 30000, odens = 100, seed = 1, plot = FALSE)#
UN_NA4 = DLFM_NA(Y[1:32,,], X[1:32,,,1:4], R = 2, avail = avail1, burn = 15000, prescan = 5000, nscan = 30000, odens = 100, seed = 1, plot = FALSE)#
UN_NA5 = DLFM_NA(Y[1:32,,], X[1:32,,,1:5], R = 2, avail = avail1, burn = 15000, prescan = 5000, nscan = 30000, odens = 100, seed = 1, plot = FALSE)
names(UN_NA1)
DLFM_NA
library(DLFM)
UN_NA
DLFM_NA
library(BayesOFsurv)
llikWeibull
mcmcOF
llikWeibull
library(devtools)
document()
setwd('/Users/bomin8319/Desktop/BayesOFsurv/pkg/R')
document()
install()
library(BayesOFsurv)
llikWeibull
llikWeibull
BayesOFsurv_llikWeibull
Rcpp.package.skeleton("BayesOFsurv")
document()
check()
install()
library(BayesOFsur)
library(BayesOFsurv)
llikWeibull
llikWeibull
mcmcOF
library(IPTM)
UpdateNum
Rprof('try.out')
library(mvtnorm)#
library(MCMCpack)#
library(BayesOFsurv)#
#
n = 1000#
nsims = 1#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
i = 1#
  #Assign parameter values#
  tru.est[i,1]<-1#
  tru.est[i,2]<-3.5#
  tru.est[i,3]<--2#
  tru.est[i,4]<-2#
  tru.est[i,5]<-3#
  tru.est[i,6]<-1#
  myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
  y <- rexp(n, rate = myrates) # generates the r.v.#
  cen <- rexp(n, rate = 1 )#
  ycen <- pmin(y, cen)#
  di <- as.numeric(y <= cen)#
  tru.est[i,7]<-table(di)[1]#
  #create parameters for ZG#
  alpha<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
  print(mean(alpha))#
  yzero<-matrix(1,n,1)#
  error<--1*rlogis(n)#
  flag<-error<qlogis(alpha)#
  yzero[flag]<-error[flag]#
  flag<-yzero==1#
  di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
  tru.est[i,8]<-table(di)[1]#
  data<-cbind(ycen,di,x,z)#
  data<-data#
  Y<-ycen#
  C<-di#
  X<-cbind(1,x)#
  Z<-cbind(1,z,x)#
######### Try fit the data using Bayesian OF model #############  #
Weibull = mcmcOF(Y, C, X, Z, N = 5000, burn = 1000, thin = 10,  w = c(1, 1, 1), m = 10, form = "Weibull", seed = 100)
summaryRprof('try.out')
summary(mcmc(Weibull$beta))#
summary(mcmc(Weibull$gamma))#
summary(mcmc(Weibull$lambda))
par(mfrow = c(2,4))#
plot(Weibull$loglike, type = 'l')#
for (p in 1:2) {#
  plot(Weibull$beta[,p], type = 'l')#
}#
for (p in 1:3) {#
  plot(Weibull$gamma[,p], type = 'l')#
}#
plot(Weibull$lambda, type = 'l')
head(tru.est)
alpa
alpha
rm(list=ls())
alpha
beta
document()
library(Rcpp)
library(RcppArmadillo)
sourceCpp('~/Desktop/BayesOFsurv/pkg/src/sampler.cpp')
sourceCpp('~/Desktop/BayesOFsurv/pkg/src/sampler.cpp')
sourceCpp('~/Desktop/BayesOFsurv/pkg/src/sampler.cpp')
document()
check()
install()
document()
install()
rm(list=ls())
Rprof('try.out')
library(mvtnorm)#
library(MCMCpack)#
library(BayesOFsurv)#
#
n = 1000#
nsims = 1#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
i = 1#
  #Assign parameter values#
  tru.est[i,1]<-1#
  tru.est[i,2]<-3.5#
  tru.est[i,3]<--2#
  tru.est[i,4]<-2#
  tru.est[i,5]<-3#
  tru.est[i,6]<-1#
  myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
  y <- rexp(n, rate = myrates) # generates the r.v.#
  cen <- rexp(n, rate = 1 )#
  ycen <- pmin(y, cen)#
  di <- as.numeric(y <= cen)#
  tru.est[i,7]<-table(di)[1]#
  #create parameters for ZG#
  alpha<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
  print(mean(alpha))#
  yzero<-matrix(1,n,1)#
  error<--1*rlogis(n)#
  flag<-error<qlogis(alpha)#
  yzero[flag]<-error[flag]#
  flag<-yzero==1#
  di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
  tru.est[i,8]<-table(di)[1]#
  data<-cbind(ycen,di,x,z)#
  data<-data#
  Y<-ycen#
  C<-di#
  X<-cbind(1,x)#
  Z<-cbind(1,z,x)#
######### Try fit the data using Bayesian OF model #############  #
Weibull = mcmcOF(Y, C, X, Z, N = 5000, burn = 1000, thin = 10,  w = c(1, 1, 1), m = 10, form = "Weibull", seed = 100)
summaryRprof('try.out')
par(mfrow = c(2,3))#
for (p in 1:2) {#
  plot(Weibull$beta[,p], type = 'l')#
}#
for (p in 1:3) {#
  plot(Weibull$gamma[,p], type = 'l')#
}#
plot(Weibull$lambda, type = 'l')
head(tru.est)
document()
install()
Rprof('try.out')
library(mvtnorm)#
library(MCMCpack)#
library(BayesOFsurv)#
#
n = 1000#
nsims = 1#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
i = 1#
  #Assign parameter values#
  tru.est[i,1]<-1#
  tru.est[i,2]<-3.5#
  tru.est[i,3]<--2#
  tru.est[i,4]<-2#
  tru.est[i,5]<-3#
  tru.est[i,6]<-1#
  myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
  y <- rexp(n, rate = myrates) # generates the r.v.#
  cen <- rexp(n, rate = 1 )#
  ycen <- pmin(y, cen)#
  di <- as.numeric(y <= cen)#
  tru.est[i,7]<-table(di)[1]#
  #create parameters for ZG#
  alpha<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
  print(mean(alpha))#
  yzero<-matrix(1,n,1)#
  error<--1*rlogis(n)#
  flag<-error<qlogis(alpha)#
  yzero[flag]<-error[flag]#
  flag<-yzero==1#
  di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
  tru.est[i,8]<-table(di)[1]#
  data<-cbind(ycen,di,x,z)#
  data<-data#
  Y<-ycen#
  C<-di#
  X<-cbind(1,x)#
  Z<-cbind(1,z,x)#
######### Try fit the data using Bayesian OF model #############  #
Weibull = mcmcOF(Y, C, X, Z, N = 5000, burn = 1000, thin = 10,  w = c(1, 1, 1), m = 10, form = "Weibull", seed = 100)
summaryRprof('try.out')
summary(mcmc(Weibull$beta))#
summary(mcmc(Weibull$gamma))#
summary(mcmc(Weibull$lambda))
par(mfrow = c(2,3))#
for (p in 1:2) {#
  plot(Weibull$beta[,p], type = 'l')#
}#
for (p in 1:3) {#
  plot(Weibull$gamma[,p], type = 'l')#
}#
plot(Weibull$lambda, type = 'l')
Weibull = mcmcOF(Y, C, X, Z, N = 1000, burn = 100, thin = 5,  w = c(1, 1, 1), m = 10, form = "Weibull", seed = 100)
summary(mcmc(Weibull$beta))#
summary(mcmc(Weibull$gamma))#
summary(mcmc(Weibull$lambda))
par(mfrow = c(2,3))#
for (p in 1:2) {#
  plot(Weibull$beta[,p], type = 'l')#
}#
for (p in 1:3) {#
  plot(Weibull$gamma[,p], type = 'l')#
}#
plot(Weibull$lambda, type = 'l')
Weibull = mcmcOF(Y, C, X, Z, N = 2000, burn = 500, thin = 10,  w = c(1, 1, 1), m = 10, form = "Weibull", seed = 100)
summary(mcmc(Weibull$beta))#
summary(mcmc(Weibull$gamma))#
summary(mcmc(Weibull$lambda))
par(mfrow = c(2,3))#
for (p in 1:2) {#
  plot(Weibull$beta[,p], type = 'l')#
}#
for (p in 1:3) {#
  plot(Weibull$gamma[,p], type = 'l')#
}#
plot(Weibull$lambda, type = 'l')
geweke.diag(Weibull$beta)
geweke.diag(Weibull$gamma)
geweke.diag(Weibull$lambda)
######### Try fit the data using Bayesian OF model #############  #
Weibull = mcmcOF(Y, C, X, Z, N = 2000, burn = 500, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull", seed = 100)#
summary(mcmc(Weibull$beta))#
summary(mcmc(Weibull$gamma))#
summary(mcmc(Weibull$lambda))#
par(mfrow = c(2,3))#
for (p in 1:2) {#
  plot(Weibull$beta[,p], type = 'l')#
}#
for (p in 1:3) {#
  plot(Weibull$gamma[,p], type = 'l')#
}#
plot(Weibull$lambda, type = 'l')
geweke.diag(Weibull$beta)
geweke.diag(Weibull$gamma)
Weibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull", seed = 100)#
summary(mcmc(Weibull$beta))#
summary(mcmc(Weibull$gamma))#
summary(mcmc(Weibull$lambda))#
par(mfrow = c(2,3))#
for (p in 1:2) {#
  plot(Weibull$beta[,p], type = 'l')#
}#
for (p in 1:3) {#
  plot(Weibull$gamma[,p], type = 'l')#
}#
plot(Weibull$lambda, type = 'l')
geweke.diag(Weibull$beta)
geweke.diag(Weibull$gamma)
geweke.diag(Weibull$lambda)
Exponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential", seed = 100)#
summary(mcmc(Weibull$beta))#
summary(mcmc(Weibull$gamma))#
summary(mcmc(Weibull$lambda))#
par(mfrow = c(2,3))#
for (p in 1:2) {#
  plot(Weibull$beta[,p], type = 'l')#
}#
for (p in 1:3) {#
  plot(Weibull$gamma[,p], type = 'l')#
}#
plot(Weibull$lambda, type = 'l')
summary(mcmc(Exponential$beta))
summary(mcmc(Exponential$gamma))
summary(mcmc(Exponential$lambda))
par(mfrow = c(2,3))#
for (p in 1:2) {#
  plot(Exponential$beta[,p], type = 'l')#
}#
for (p in 1:3) {#
  plot(Exponential$gamma[,p], type = 'l')#
}#
plot(Exponential$lambda, type = 'l')
document()
install()
names(tru.est)
###############
####Set Up#####
###############
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(3)   #
#set the number of observations#
n<-1000#
#set the number of simulations, and create matrices to store the results#
nsims<-1000#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=14)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=18)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=7)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=9)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=7)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=9)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
#create a dependent variable, begin the simmulations#
for(i in 1:nsims){#
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log((1-phi)+phi*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log((1-phi)+phi*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
}#
#combine matrices and label variables#
main.data<-cbind(tru.est,cox.est,exp.est,weib.est,cox.rmse,exp.rmse,weib.rmse,cox.cp,exp.cp,weib.cp)#
colnames(main.data)<-c("true.x0","true.x1","true.z0","true.z1","true.z2","true.p","cen.lat","cen.obs","cox.x1","cox.x1.se","exp.x0","exp.x0.se","exp.x1","exp.x1.se",#
	"zexp.z0","zexp.z0.se","zexp.z1","zexp.z1.se","zexp.z2","zexp.z2.se","zexp.x0","zexp.x0.se","zexp.x1","zexp.x1.se","wei.x0","wei.x0.se","wei.x1","wei.x1.se","wei.p","wei.p.se",#
	"zwei.z0","zwei.z0.se","zwei.z1","zwei.z1.se","zwei.z2","zwei.z2.se","zwei.x0","zwei.x0.se","zwei.x1","zwei.x1.se","zwei.p","zwei.p.se","cox.x1.rmse",#
	"exp.x0.rmse","exp.x1.rmse","zexp.z0.rmse","zexp.z1.rmse","zexp.z2.rmse","zexp.x0.rmse","zexp.x1.rmse","wei.x0.rmse","wei.x1.rmse","wei.p.rmse","zwei.z0.rmse","zwei.z1.rmse","zwei.z2.rmse",#
	"zwei.x0.rmse","zwei.x1.rmse","zwei.p.rmse","cox.x1.cp","exp.x0.cp","exp.x1.cp","zexp.z0.cp","zexp.z1.cp","zexp.z2.cp","zexp.x0.cp","zexp.x1.cp","wei.x0.cp","wei.x1.cp","wei.p.cp",#
	"zwei.z0.cp","zwei.z1.cp","zwei.z2.cp","zwei.x0.cp","zwei.x1.cp","zwei.p.cp")#
#save dataset#
main.data<-as.data.frame(main.data)
head(main.data)
document()
summary(mcmc(Weibull$beta))
Weibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull", seed = 100)
summary(mcmc(Weibull$beta))
output.ZWeibull
summary(mcmc(Weibull$beta))
summary(mcmc(Weibull$beta))[[1]]
output.BayesZExponential = list(betas = summary(mcmc(BayesZExponential$beta))[[1]][,1])
summary(mcmc(Weibull$beta))[[1]][,1]
summary(mcmc(Weibull$gammaa))[[1]][,1]
summary(mcmc(Weibull$gamma))[[1]][,1]
summary(mcmc(Weibull$lambda))[[1]][,1]
summary(mcmc(Weibull$lambda))[[1]]
summary(mcmc(Weibull$lambda))[[1]][1]
head(main.dta)
head(main.data)
summary(mcmc(Weibull$lambda))[[1]]
summary(mcmc(Weibull$gamma))[[1]]
?mcmc
?summary
MCMCpack::summary
flag
yzero
di
head(main.data)
###############
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(3)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-1#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=18)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=7)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=9)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=7)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=9)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
#create a dependent variable, begin the simmulations#
for(i in 1:nsims){#
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]))
###############
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(3)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-1#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=18)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=7)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=9)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=7)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=9)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
#create a dependent variable, begin the simmulations#
for(i in 1:nsims){#
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]))
}
BayesZExponential
exp.est
#combine matrices and label variables#
main.data<-cbind(tru.est,cox.est,exp.est,weib.est,cox.rmse,exp.rmse,weib.rmse,cox.cp,exp.cp,weib.cp)#
colnames(main.data)<-c("true.x0","true.x1","true.z0","true.z1","true.z2","true.p","cen.lat","cen.obs","cox.x1","cox.x1.se","exp.x0","exp.x0.se","exp.x1","exp.x1.se",#
	"zexp.z0","zexp.z0.se","zexp.z1","zexp.z1.se","zexp.z2","zexp.z2.se","zexp.x0","zexp.x0.se","zexp.x1","zexp.x1.se","wei.x0","wei.x0.se","wei.x1","wei.x1.se","wei.p","wei.p.se",#
	"zwei.z0","zwei.z0.se","zwei.z1","zwei.z1.se","zwei.z2","zwei.z2.se","zwei.x0","zwei.x0.se","zwei.x1","zwei.x1.se","zwei.p","zwei.p.se","cox.x1.rmse",#
	"exp.x0.rmse","exp.x1.rmse","zexp.z0.rmse","zexp.z1.rmse","zexp.z2.rmse","zexp.x0.rmse","zexp.x1.rmse","wei.x0.rmse","wei.x1.rmse","wei.p.rmse","zwei.z0.rmse","zwei.z1.rmse","zwei.z2.rmse",#
	"zwei.x0.rmse","zwei.x1.rmse","zwei.p.rmse","cox.x1.cp","exp.x0.cp","exp.x1.cp","zexp.z0.cp","zexp.z1.cp","zexp.z2.cp","zexp.x0.cp","zexp.x1.cp","wei.x0.cp","wei.x1.cp","wei.p.cp",#
	"zwei.z0.cp","zwei.z1.cp","zwei.z2.cp","zwei.x0.cp","zwei.x1.cp","zwei.p.cp")
main.data
names(main.data)<-c("true.x0","true.x1","true.z0","true.z1","true.z2","true.p","cen.lat","cen.obs","cox.x1","cox.x1.se","exp.x0","exp.x0.se","exp.x1","exp.x1.se",#
	"zexp.z0","zexp.z0.se","zexp.z1","zexp.z1.se","zexp.z2","zexp.z2.se","zexp.x0","zexp.x0.se","zexp.x1","zexp.x1.se","wei.x0","wei.x0.se","wei.x1","wei.x1.se","wei.p","wei.p.se",#
	"zwei.z0","zwei.z0.se","zwei.z1","zwei.z1.se","zwei.z2","zwei.z2.se","zwei.x0","zwei.x0.se","zwei.x1","zwei.x1.se","zwei.p","zwei.p.se","cox.x1.rmse",#
	"exp.x0.rmse","exp.x1.rmse","zexp.z0.rmse","zexp.z1.rmse","zexp.z2.rmse","zexp.x0.rmse","zexp.x1.rmse","wei.x0.rmse","wei.x1.rmse","wei.p.rmse","zwei.z0.rmse","zwei.z1.rmse","zwei.z2.rmse",#
	"zwei.x0.rmse","zwei.x1.rmse","zwei.p.rmse","cox.x1.cp","exp.x0.cp","exp.x1.cp","zexp.z0.cp","zexp.z1.cp","zexp.z2.cp","zexp.x0.cp","zexp.x1.cp","wei.x0.cp","wei.x1.cp","wei.p.cp",#
	"zwei.z0.cp","zwei.z1.cp","zwei.z2.cp","zwei.x0.cp","zwei.x1.cp","zwei.p.cp")
main.data
main.data<-cbind(tru.est,cox.est,exp.est,weib.est,cox.rmse,exp.rmse,weib.rmse,cox.cp,exp.cp,weib.cp)#
colnames(main.data)<-c("true.x0","true.x1","true.z0","true.z1","true.z2","true.p","cen.lat","cen.obs","cox.x1","cox.x1.se","exp.x0","exp.x0.se","exp.x1","exp.x1.se",#
	"zexp.z0","zexp.z0.se","zexp.z1","zexp.z1.se","zexp.z2","zexp.z2.se","zexp.x0","zexp.x0.se","zexp.x1","zexp.x1.se","wei.x0","wei.x0.se","wei.x1","wei.x1.se","wei.p","wei.p.se",#
	"zwei.z0","zwei.z0.se","zwei.z1","zwei.z1.se","zwei.z2","zwei.z2.se","zwei.x0","zwei.x0.se","zwei.x1","zwei.x1.se","zwei.p","zwei.p.se","cox.x1.rmse",#
	"exp.x0.rmse","exp.x1.rmse","zexp.z0.rmse","zexp.z1.rmse","zexp.z2.rmse","zexp.x0.rmse","zexp.x1.rmse","wei.x0.rmse","wei.x1.rmse","wei.p.rmse","zwei.z0.rmse","zwei.z1.rmse","zwei.z2.rmse",#
	"zwei.x0.rmse","zwei.x1.rmse","zwei.p.rmse","cox.x1.cp","exp.x0.cp","exp.x1.cp","zexp.z0.cp","zexp.z1.cp","zexp.z2.cp","zexp.x0.cp","zexp.x1.cp","wei.x0.cp","wei.x1.cp","wei.p.cp",#
	"zwei.z0.cp","zwei.z1.cp","zwei.z2.cp","zwei.x0.cp","zwei.x1.cp","zwei.p.cp")
exp.est
output.BayesZExponential
tru.est
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]))
output.BayesZExponential
summary(mcmc(BayesZExponential$beta))[[2]]
summary(mcmc(BayesZExponential$beta))[[1]]
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = c(summary(mcmc(BayesZExponential$beta))[[2]][,c(1,5)], summary(mcmc(BayesZExponential$gamma))[[2]][,c(1,5)]))
output.BayesZExponential
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = cbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))
output.BayesZExponential
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))
output.BayesZweibull
output.BayesZWeibull
# # #clear memory#
# rm( list=ls() )#
# #load necessary libraries 						                                 #
# library(foreign)#
# library(Zelig)#
# library(car)#
# library(MASS)#
# library(VGAM)#
# library(plotrix)#
# library(pscl)#
# library(survival)#
# library(msm)#
# library(verification)#
# library(corpcor)#
# library(Design)#
# library(mvtnorm)#
# library(MCMCpack)#
# library(devtools)#
# install_github('bomin8319/BayesOFsurv/pkg')#
# library(BayesOFsurv)#
# #set working directory#
# setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
# ###########################################################################
# ###########################################################################
# ############################Monte Carlo####################################
# ###########################################################################
# #set seed#
# set.seed(3)   #
# #set the number of observations#
# n<-100#
# #set the number of simulations, and create matrices to store the results#
# nsims<-1#
# #history matrix for true estimates#
# tru.est<-matrix(NA,nrow=nsims,ncol=8)#
# #history matrix for cox estimates#
# cox.est<-matrix(NA,nrow=nsims,ncol=2)#
# #history matrix for exp estimates#
# exp.est<-matrix(NA,nrow=nsims,ncol=24)#
# #history matrix for weibull estimates#
# weib.est<-matrix(NA,nrow=nsims,ncol=30)#
# #history matrix for cox RMSE#
# cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
# #history matrix for exp RMSE#
# exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
# #history matrix for exp RMSE#
# weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
# #history matrix for cox CP#
# cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
# #history matrix for exp CP#
# exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
# #history matrix for exp CP#
# weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
# #create covariates#
# x<-runif(n, min=-2.5, max=12)#
# z<-log(runif(n, min=1, max=100))#
# #create a dependent variable, begin the simmulations#
# for(i in 1:nsims){#
# #Assign parameter values#
# tru.est[i,1]<-1#
# tru.est[i,2]<-3.5#
# tru.est[i,3]<--2#
# tru.est[i,4]<-2#
# tru.est[i,5]<-3#
# tru.est[i,6]<-1#
# myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
# y <- rexp(n, rate = myrates) # generates the r.v.#
# cen <- rexp(n, rate = 1 )#
# ycen <- pmin(y, cen)#
# di <- as.numeric(y <= cen)#
# tru.est[i,7]<-table(di)[1]#
# #create parameters for ZG#
# phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
# print(mean(phi))#
# yzero<-matrix(1,n,1)#
# error<--1*rlogis(n)#
# flag<-error<qlogis(phi)#
# yzero[flag]<-error[flag]#
# flag<-yzero==1#
# di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
# tru.est[i,8]<-table(di)[1]#
# data<-cbind(ycen,di,x,z)#
# ######################################################################################
# ###################################COX Model##########################################
# ######################################################################################
# #store estimate and se#
# cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
# cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
# #store rmse#
# cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
# #calculate upper and lower 95% CI's#
# b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
# b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
# #store coverage parameters#
# cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
# ##############################################################################
# ########################Simple Exponential Model##############################
# ##############################################################################
# Exponential<- function(est,Y,C,X,data) {					      #
	# n=nrow(data)							      					  #
	# llik <- matrix(0, nrow=n, ncol = 1)#
	# beta<-est[1:length(est)]#
	# XB<-X%*%beta#
	# llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	# llik<--1*sum(llik)#
	# return(llik)#
	# }#
# #set starting parameters#
# est<-rbind(.01,.01)#
# #set data, Y and X#
# data<-data#
# Y<-ycen#
# C<-di#
# X<-cbind(1,x)#
# #optimize#
# output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
# if(class(output.Exponential)=="list"){#
	# ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
# #store betas and ses#
# exp.est[i,1]<-output.Exponential$par[1]#
# exp.est[i,2]<-sqrt(vcv[1,1])#
# exp.est[i,3]<-output.Exponential$par[2]#
# exp.est[i,4]<-sqrt(vcv[2,2])#
# #store rmse#
# exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
# exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
# #calculate upper and lower 95% CI's#
# b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
# b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
# b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
# b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
# #store coverage parameters#
# exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
# exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
# }#
# #################################################################################
# #########################Simple Weibull Model ###################################
# #################################################################################
# #Note this estiamtes the model via hazard rates, a la Stata#
# test<-survreg(Surv(ycen, di)~x, dist="weibull")#
# summary(test)#
# Weibull<- function(est,Y,C,X,data) {					      #
	# n=nrow(data)							      					  #
	# llik <- matrix(0, nrow=n, ncol = 1)#
	# beta<-est[1:length(est)-1]#
	# p<-est[length(est)]#
	# p<-exp(p)#
	# XB<-X%*%beta#
	# llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	# llik<--1*sum(llik)#
	# return(llik)#
	# }#
# #set starting parameters#
# est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
# #set data, Y and X#
# data<-data#
# Y<-ycen#
# C<-di#
# X<-cbind(1,x)#
# #optimize#
# output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
# if(class(output.Weibull)=="list"){#
	# ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
# #store betas and ses#
# weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
# coeff<-c(weib.est[i,1],output.Weibull$par[3])#
# varcov<-matrix(NA,2,2)#
# varcov[1,1]<-vcv[1,1]#
# varcov[1,2]<-vcv[1,3]#
# varcov[2,1]<-vcv[3,1]#
# varcov[2,2]<-vcv[3,3]#
# weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
# weib.est[i,3]<-output.Weibull$par[2]#
# weib.est[i,4]<-sqrt(vcv[2,2])#
# weib.est[i,5]<-exp(output.Weibull$par[3])#
# coeff<-c(weib.est[i,5])#
# varcov<-matrix(NA,1,1)#
# varcov[1,1]<-vcv[3,3]#
# weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
# #store rmse#
# weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
# weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
# weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
# #calculate upper and lower 95% CI's#
# b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
# b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
# b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
# b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
# p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
# p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
# #store coverage parameters#
# weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
# weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
# weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
# }#
# ###logit estimates####
# dataset<-as.data.frame(data)#
# logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
# logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
# logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
# ################################################################################
# ##########################Zombie Exponential Model##############################
# ################################################################################
# #This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
# ZExponential<- function(est,Y,C,X,Z,data) {					      #
	# n=nrow(data)							      					  #
	# llik <- matrix(0, nrow=n, ncol = 1)#
	# gamma<-est[1:ncol(Z)]#
	# beta<-est[(ncol(Z)+1):length(est)]#
	# XB<-X%*%beta#
	# ZG<-Z%*%gamma#
	# phi<-1/(1+exp(-ZG))#
	# llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	# llik<--1*sum(llik)#
	# return(llik)#
	# }#
# #set starting parameters#
# est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
# #set data, Y and X#
# data<-data#
# Y<-ycen#
# C<-di#
# X<-cbind(1,x)#
# Z<-cbind(1,z,x)#
# #optimize#
# output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
# if(class(output.ZExponential)=="list"){#
	# ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
# #store betas and ses#
# exp.est[i,5]<-output.ZExponential$par[1]#
# exp.est[i,6]<-sqrt(vcv[1,1])#
# exp.est[i,7]<-output.ZExponential$par[2]#
# exp.est[i,8]<-sqrt(vcv[2,2])#
# exp.est[i,9]<-output.ZExponential$par[3]#
# exp.est[i,10]<-sqrt(vcv[3,3])#
# exp.est[i,11]<-output.ZExponential$par[4]#
# exp.est[i,12]<-sqrt(vcv[4,4])#
# exp.est[i,13]<-output.ZExponential$par[5]#
# exp.est[i,14]<-sqrt(vcv[5,5])#
# #store rmse#
# exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
# exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
# exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
# exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
# exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
# #calculate upper and lower 95% CI's#
# g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
# g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
# g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
# g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
# g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
# g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
# b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
# b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
# b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
# b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
# #store coverage parameters#
# exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
# exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
# exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
# exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
# exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
# }#
# ######################################################################################
# ##########################Zombie Weibull Model #######################################
# ######################################################################################
# #This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
# ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	# n=nrow(data)							      					  #
	# llik <- matrix(0, nrow=n, ncol = 1)#
	# gamma<-est[1:ncol(Z)]#
	# beta<-est[(ncol(Z)+1):(length(est)-1)]#
	# p<-est[length(est)]#
	# p<-exp(p)#
	# XB<-X%*%beta#
	# ZG<-Z%*%gamma#
	# phi<-1/(1+exp(-(ZG+1/p)))#
	# llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	# llik<--1*sum(llik)#
	# return(llik)#
	# }#
# #set starting parameters#
# est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
# #set data, Y and X#
# data<-data#
# Y<-ycen#
# C<-di#
# X<-cbind(1,x)#
# Z<-cbind(1,z,x)#
# #optimize#
# output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
# if(class(output.ZWeibull)=="list"){#
	# ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
# #store betas and ses#
# weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
# coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
# varcov<-matrix(NA,2,2)#
# varcov[1,1]<-vcv[1,1]#
# varcov[1,2]<-vcv[1,6]#
# varcov[2,1]<-vcv[6,1]#
# varcov[2,2]<-vcv[6,6]#
# weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
# weib.est[i,9]<-output.ZWeibull$par[2]#
# weib.est[i,10]<-sqrt(vcv[2,2])#
# weib.est[i,11]<-output.ZWeibull$par[3]#
# weib.est[i,12]<-sqrt(vcv[3,3])#
# weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
# coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
# varcov<-matrix(NA,2,2)#
# varcov[1,1]<-vcv[4,4]#
# varcov[1,2]<-vcv[4,6]#
# varcov[2,1]<-vcv[6,4]#
# varcov[2,2]<-vcv[6,6]#
# weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
# weib.est[i,15]<-output.ZWeibull$par[5]#
# weib.est[i,16]<-sqrt(vcv[5,5])#
# weib.est[i,17]<-exp(output.ZWeibull$par[6])#
# coeff<-c(weib.est[i,17])#
# varcov<-matrix(NA,1,1)#
# varcov[1,1]<-vcv[6,6]#
# weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
# #store rmse#
# weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
# weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
# weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
# weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
# weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
# weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
# #calculate upper and lower 95% CI's#
# g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
# g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
# g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
# g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
# g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
# g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
# b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
# b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
# b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
# b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
# p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
# p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
# #store coverage parameters#
# weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
# weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
# weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
# weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
# weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
# weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
# }#
# ################################################################################
# ######################Bayesian Zombie Exponential Model#########################
# ################################################################################
# #set data, Y and X#
# data<-data#
# Y<-ycen#
# C<-di#
# X<-cbind(1,x)#
# Z<-cbind(1,z,x)#
# BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
# output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								# se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								# CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
# exp.est[i,15]<-output.BayesZExponential$par[1]#
# exp.est[i,16]<-output.BayesZExponential$se[1]#
# exp.est[i,17]<-output.BayesZExponential$par[2]#
# exp.est[i,18]<-output.BayesZExponential$se[2]#
# exp.est[i,19]<-output.BayesZExponential$par[3]#
# exp.est[i,20]<-output.BayesZExponential$se[3]#
# exp.est[i,21]<-output.BayesZExponential$par[4]#
# exp.est[i,22]<-output.BayesZExponential$se[4]#
# exp.est[i,23]<-output.BayesZExponential$par[5]#
# exp.est[i,24]<-output.BayesZExponential$se[5]#
#
# #store rmse#
# exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
# exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
# exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
# exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
# exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
# #calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
# #store coverage parameters#
# exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
# exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
# exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
# exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
# exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
# ################################################################################
# ########################Bayesian Zombie Weibull Model###########################
# ################################################################################
# #set data, Y and X#
# data<-data#
# Y<-ycen#
# C<-di#
# X<-cbind(1,x)#
# Z<-cbind(1,z,x)#
# BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
# output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									# summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								# se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   # summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								# CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										# summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
# weib.est[i,19]<-output.BayesZWeibull$par[1]#
# weib.est[i,20]<-output.BayesZWeibull$se[1]#
# weib.est[i,21]<-output.BayesZWeibull$par[2]#
# weib.est[i,22]<-output.BayesZWeibull$se[2]#
# weib.est[i,23]<-output.BayesZWeibull$par[3]#
# weib.est[i,24]<-output.BayesZWeibull$se[3]#
# weib.est[i,25]<-output.BayesZWeibull$par[4]#
# weib.est[i,26]<-output.BayesZWeibull$se[4]#
# weib.est[i,27]<-output.BayesZWeibull$par[5]#
# weib.est[i,28]<-output.BayesZWeibull$se[5]#
# weib.est[i,29]<-output.BayesZWeibull$par[6]#
# weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
# #store rmse#
# weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
# weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
# weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
# weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
# weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
# weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
# #calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
# #store coverage parameters#
# weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
# weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
# weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
# weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
# weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
# weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
# }#
# #combine matrices and label variables#
# main.data<-cbind(tru.est, cox.est, exp.est, weib.est, cox.rmse, exp.rmse, weib.rmse, cox.cp, exp.cp, weib.cp)
# # #clear memory#
# rm( list=ls() )#
# #load necessary libraries 						                                 #
# library(foreign)#
# library(Zelig)#
# library(car)#
# library(MASS)#
# library(VGAM)#
# library(plotrix)#
# library(pscl)#
# library(survival)#
# library(msm)#
# library(verification)#
# library(corpcor)#
# library(Design)#
# library(mvtnorm)#
# library(MCMCpack)#
# library(devtools)#
# install_github('bomin8319/BayesOFsurv/pkg')#
# library(BayesOFsurv)#
# #set working directory#
# setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
# ###########################################################################
# ###########################################################################
# ############################Monte Carlo####################################
# ###########################################################################
# #set seed#
# set.seed(3)   #
# #set the number of observations#
# n<-100#
# #set the number of simulations, and create matrices to store the results#
# nsims<-1#
# #history matrix for true estimates#
# tru.est<-matrix(NA,nrow=nsims,ncol=8)#
# #history matrix for cox estimates#
# cox.est<-matrix(NA,nrow=nsims,ncol=2)#
# #history matrix for exp estimates#
# exp.est<-matrix(NA,nrow=nsims,ncol=24)#
# #history matrix for weibull estimates#
# weib.est<-matrix(NA,nrow=nsims,ncol=30)#
# #history matrix for cox RMSE#
# cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
# #history matrix for exp RMSE#
# exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
# #history matrix for exp RMSE#
# weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
# #history matrix for cox CP#
# cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
# #history matrix for exp CP#
# exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
# #history matrix for exp CP#
# weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
# #create covariates#
# x<-runif(n, min=-2.5, max=12)#
# z<-log(runif(n, min=1, max=100))#
# #create a dependent variable, begin the simmulations#
# for(i in 1:nsims){#
# #Assign parameter values#
# tru.est[i,1]<-1#
# tru.est[i,2]<-3.5#
# tru.est[i,3]<--2#
# tru.est[i,4]<-2#
# tru.est[i,5]<-3#
# tru.est[i,6]<-1#
# myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
# y <- rexp(n, rate = myrates) # generates the r.v.#
# cen <- rexp(n, rate = 1 )#
# ycen <- pmin(y, cen)#
# di <- as.numeric(y <= cen)#
# tru.est[i,7]<-table(di)[1]#
# #create parameters for ZG#
# phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
# print(mean(phi))#
# yzero<-matrix(1,n,1)#
# error<--1*rlogis(n)#
# flag<-error<qlogis(phi)#
# yzero[flag]<-error[flag]#
# flag<-yzero==1#
# di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
# tru.est[i,8]<-table(di)[1]#
# data<-cbind(ycen,di,x,z)#
# ######################################################################################
# ###################################COX Model##########################################
# ######################################################################################
# #store estimate and se#
# cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
# cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
# #store rmse#
# cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
# #calculate upper and lower 95% CI's#
# b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
# b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
# #store coverage parameters#
# cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
# ##############################################################################
# ########################Simple Exponential Model##############################
# ##############################################################################
# Exponential<- function(est,Y,C,X,data) {					      #
	# n=nrow(data)							      					  #
	# llik <- matrix(0, nrow=n, ncol = 1)#
	# beta<-est[1:length(est)]#
	# XB<-X%*%beta#
	# llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	# llik<--1*sum(llik)#
	# return(llik)#
	# }#
# #set starting parameters#
# est<-rbind(.01,.01)#
# #set data, Y and X#
# data<-data#
# Y<-ycen#
# C<-di#
# X<-cbind(1,x)#
# #optimize#
# output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
# if(class(output.Exponential)=="list"){#
	# ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
# #store betas and ses#
# exp.est[i,1]<-output.Exponential$par[1]#
# exp.est[i,2]<-sqrt(vcv[1,1])#
# exp.est[i,3]<-output.Exponential$par[2]#
# exp.est[i,4]<-sqrt(vcv[2,2])#
# #store rmse#
# exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
# exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
# #calculate upper and lower 95% CI's#
# b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
# b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
# b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
# b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
# #store coverage parameters#
# exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
# exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
# }#
# #################################################################################
# #########################Simple Weibull Model ###################################
# #################################################################################
# #Note this estiamtes the model via hazard rates, a la Stata#
# test<-survreg(Surv(ycen, di)~x, dist="weibull")#
# summary(test)#
# Weibull<- function(est,Y,C,X,data) {					      #
	# n=nrow(data)							      					  #
	# llik <- matrix(0, nrow=n, ncol = 1)#
	# beta<-est[1:length(est)-1]#
	# p<-est[length(est)]#
	# p<-exp(p)#
	# XB<-X%*%beta#
	# llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	# llik<--1*sum(llik)#
	# return(llik)#
	# }#
# #set starting parameters#
# est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
# #set data, Y and X#
# data<-data#
# Y<-ycen#
# C<-di#
# X<-cbind(1,x)#
# #optimize#
# output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
# if(class(output.Weibull)=="list"){#
	# ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
# #store betas and ses#
# weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
# coeff<-c(weib.est[i,1],output.Weibull$par[3])#
# varcov<-matrix(NA,2,2)#
# varcov[1,1]<-vcv[1,1]#
# varcov[1,2]<-vcv[1,3]#
# varcov[2,1]<-vcv[3,1]#
# varcov[2,2]<-vcv[3,3]#
# weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
# weib.est[i,3]<-output.Weibull$par[2]#
# weib.est[i,4]<-sqrt(vcv[2,2])#
# weib.est[i,5]<-exp(output.Weibull$par[3])#
# coeff<-c(weib.est[i,5])#
# varcov<-matrix(NA,1,1)#
# varcov[1,1]<-vcv[3,3]#
# weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
# #store rmse#
# weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
# weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
# weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
# #calculate upper and lower 95% CI's#
# b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
# b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
# b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
# b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
# p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
# p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
# #store coverage parameters#
# weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
# weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
# weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
# }#
# ###logit estimates####
# dataset<-as.data.frame(data)#
# logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
# logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
# logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
# ################################################################################
# ##########################Zombie Exponential Model##############################
# ################################################################################
# #This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
# ZExponential<- function(est,Y,C,X,Z,data) {					      #
	# n=nrow(data)							      					  #
	# llik <- matrix(0, nrow=n, ncol = 1)#
	# gamma<-est[1:ncol(Z)]#
	# beta<-est[(ncol(Z)+1):length(est)]#
	# XB<-X%*%beta#
	# ZG<-Z%*%gamma#
	# phi<-1/(1+exp(-ZG))#
	# llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	# llik<--1*sum(llik)#
	# return(llik)#
	# }#
# #set starting parameters#
# est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
# #set data, Y and X#
# data<-data#
# Y<-ycen#
# C<-di#
# X<-cbind(1,x)#
# Z<-cbind(1,z,x)#
# #optimize#
# output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
# if(class(output.ZExponential)=="list"){#
	# ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
# #store betas and ses#
# exp.est[i,5]<-output.ZExponential$par[1]#
# exp.est[i,6]<-sqrt(vcv[1,1])#
# exp.est[i,7]<-output.ZExponential$par[2]#
# exp.est[i,8]<-sqrt(vcv[2,2])#
# exp.est[i,9]<-output.ZExponential$par[3]#
# exp.est[i,10]<-sqrt(vcv[3,3])#
# exp.est[i,11]<-output.ZExponential$par[4]#
# exp.est[i,12]<-sqrt(vcv[4,4])#
# exp.est[i,13]<-output.ZExponential$par[5]#
# exp.est[i,14]<-sqrt(vcv[5,5])#
# #store rmse#
# exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
# exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
# exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
# exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
# exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
# #calculate upper and lower 95% CI's#
# g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
# g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
# g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
# g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
# g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
# g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
# b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
# b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
# b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
# b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
# #store coverage parameters#
# exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
# exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
# exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
# exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
# exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
# }#
# ######################################################################################
# ##########################Zombie Weibull Model #######################################
# ######################################################################################
# #This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
# ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	# n=nrow(data)							      					  #
	# llik <- matrix(0, nrow=n, ncol = 1)#
	# gamma<-est[1:ncol(Z)]#
	# beta<-est[(ncol(Z)+1):(length(est)-1)]#
	# p<-est[length(est)]#
	# p<-exp(p)#
	# XB<-X%*%beta#
	# ZG<-Z%*%gamma#
	# phi<-1/(1+exp(-(ZG+1/p)))#
	# llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	# llik<--1*sum(llik)#
	# return(llik)#
	# }#
# #set starting parameters#
# est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
# #set data, Y and X#
# data<-data#
# Y<-ycen#
# C<-di#
# X<-cbind(1,x)#
# Z<-cbind(1,z,x)#
# #optimize#
# output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
# if(class(output.ZWeibull)=="list"){#
	# ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
# #store betas and ses#
# weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
# coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
# varcov<-matrix(NA,2,2)#
# varcov[1,1]<-vcv[1,1]#
# varcov[1,2]<-vcv[1,6]#
# varcov[2,1]<-vcv[6,1]#
# varcov[2,2]<-vcv[6,6]#
# weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
# weib.est[i,9]<-output.ZWeibull$par[2]#
# weib.est[i,10]<-sqrt(vcv[2,2])#
# weib.est[i,11]<-output.ZWeibull$par[3]#
# weib.est[i,12]<-sqrt(vcv[3,3])#
# weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
# coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
# varcov<-matrix(NA,2,2)#
# varcov[1,1]<-vcv[4,4]#
# varcov[1,2]<-vcv[4,6]#
# varcov[2,1]<-vcv[6,4]#
# varcov[2,2]<-vcv[6,6]#
# weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
# weib.est[i,15]<-output.ZWeibull$par[5]#
# weib.est[i,16]<-sqrt(vcv[5,5])#
# weib.est[i,17]<-exp(output.ZWeibull$par[6])#
# coeff<-c(weib.est[i,17])#
# varcov<-matrix(NA,1,1)#
# varcov[1,1]<-vcv[6,6]#
# weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
# #store rmse#
# weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
# weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
# weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
# weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
# weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
# weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
# #calculate upper and lower 95% CI's#
# g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
# g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
# g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
# g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
# g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
# g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
# b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
# b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
# b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
# b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
# p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
# p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
# #store coverage parameters#
# weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
# weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
# weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
# weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
# weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
# weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
# }#
# ################################################################################
# ######################Bayesian Zombie Exponential Model#########################
# ################################################################################
# #set data, Y and X#
# data<-data#
# Y<-ycen#
# C<-di#
# X<-cbind(1,x)#
# Z<-cbind(1,z,x)#
# BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
# output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								# se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								# CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
# exp.est[i,15]<-output.BayesZExponential$par[1]#
# exp.est[i,16]<-output.BayesZExponential$se[1]#
# exp.est[i,17]<-output.BayesZExponential$par[2]#
# exp.est[i,18]<-output.BayesZExponential$se[2]#
# exp.est[i,19]<-output.BayesZExponential$par[3]#
# exp.est[i,20]<-output.BayesZExponential$se[3]#
# exp.est[i,21]<-output.BayesZExponential$par[4]#
# exp.est[i,22]<-output.BayesZExponential$se[4]#
# exp.est[i,23]<-output.BayesZExponential$par[5]#
# exp.est[i,24]<-output.BayesZExponential$se[5]#
#
# #store rmse#
# exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
# exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
# exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
# exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
# exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
# #calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
# #store coverage parameters#
# exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
# exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
# exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
# exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
# exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
# ################################################################################
# ########################Bayesian Zombie Weibull Model###########################
# ################################################################################
# #set data, Y and X#
# data<-data#
# Y<-ycen#
# C<-di#
# X<-cbind(1,x)#
# Z<-cbind(1,z,x)#
# BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
# output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									# summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								# se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   # summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								# CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										# summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
# weib.est[i,19]<-output.BayesZWeibull$par[1]#
# weib.est[i,20]<-output.BayesZWeibull$se[1]#
# weib.est[i,21]<-output.BayesZWeibull$par[2]#
# weib.est[i,22]<-output.BayesZWeibull$se[2]#
# weib.est[i,23]<-output.BayesZWeibull$par[3]#
# weib.est[i,24]<-output.BayesZWeibull$se[3]#
# weib.est[i,25]<-output.BayesZWeibull$par[4]#
# weib.est[i,26]<-output.BayesZWeibull$se[4]#
# weib.est[i,27]<-output.BayesZWeibull$par[5]#
# weib.est[i,28]<-output.BayesZWeibull$se[5]#
# weib.est[i,29]<-output.BayesZWeibull$par[6]#
# weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
# #store rmse#
# weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
# weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
# weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
# weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
# weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
# weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
# #calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
# #store coverage parameters#
# weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
# weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
# weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
# weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
# weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
# weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
# }#
# #combine matrices and label variables#
# main.data<-cbind(tru.est, cox.est, exp.est, weib.est, cox.rmse, exp.rmse, weib.rmse, cox.cp, exp.cp, weib.cp)
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(3)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-1#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
#create a dependent variable, begin the simmulations#
for(i in 1:nsims){#
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
b0.lower<-output.BayesZExponential$CI[1,1]#
b0.upper<-output.BayesZExponential$CI[1,5]#
b1.lower<-output.BayesZExponential$CI[2,1]#
b1.upper<-output.BayesZExponential$CI[2,5]#
g0.lower<-output.BayesZExponential$CI[3,1]#
g0.upper<-output.BayesZExponential$CI[3,5]#
g1.lower<-output.BayesZExponential$CI[4,1]#
g1.upper<-output.BayesZExponential$CI[4,5]#
g2.lower<-output.BayesZExponential$CI[5,1]#
g2.upper<-output.BayesZExponential$CI[5,5]#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
b0.lower<-output.BayesZWeibull$CI[1,1]#
b0.upper<-output.BayesZWeibull$CI[1,5]#
b1.lower<-output.BayesZWeibull$CI[2,1]#
b1.upper<-output.BayesZWeibull$CI[2,5]#
g0.lower<-output.BayesZWeibull$CI[3,1]#
g0.upper<-output.BayesZWeibull$CI[3,5]#
g1.lower<-output.BayesZWeibull$CI[4,1]#
g1.upper<-output.BayesZWeibull$CI[4,5]#
g2.lower<-output.BayesZWeibull$CI[5,1]#
g2.upper<-output.BayesZWeibull$CI[5,5]#
p.lower<-output.BayesZWeibull$CI[6,1]#
p.upper<-output.BayesZWeibull$CI[6,2]#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
#combine matrices and label variables#
main.data<-cbind(tru.est, cox.est, exp.est, weib.est, cox.rmse, exp.rmse, weib.rmse, cox.cp, exp.cp, weib.cp)
main.data
cox.est
exp.est
wei.est
weib.est
cox.rmse
exp.rmse
web.rmse
weib.rmse
cox.cp
exp.cp
seib.cp
weib.cp
colnames(main.data)<-c("true.x0","true.x1","true.z0","true.z1","true.z2","true.p","cen.lat","cen.obs",#
	"cox.x1","cox.x1.se",#
	"exp.x0","exp.x0.se","exp.x1","exp.x1.se",#
	"zexp.z0","zexp.z0.se","zexp.z1","zexp.z1.se","zexp.z2","zexp.z2.se","zexp.x0","zexp.x0.se","zexp.x1","zexp.x1.se",#
	"bzexp.x0","zexp.x0.se","bzexp.x1","bzexp.x1.se","bzexp.z0","bzexp.z0.se","bzexp.z1","bzexp.z1.se","bzexp.z2","bzexp.z2.se",#
	"wei.x0","wei.x0.se","wei.x1","wei.x1.se","wei.p","wei.p.se",#
	"zwei.z0","zwei.z0.se","zwei.z1","zwei.z1.se","zwei.z2","zwei.z2.se","zwei.x0","zwei.x0.se","zwei.x1","zwei.x1.se","zwei.p","zwei.p.se",#
	"bzwei.x0","bzwei.x0.se","bzwei.x1","bzwei.x1.se","bzwei.z0","bzwei.z0.se","bzwei.z1","bzwei.z1.se","bzwei.z2","bzwei.z2.se","bzwei.p","bzwei.p.se",#
	"cox.x1.rmse",#
	"exp.x0.rmse","exp.x1.rmse","zexp.z0.rmse","zexp.z1.rmse","zexp.z2.rmse","zexp.x0.rmse","zexp.x1.rmse","bzexp.x0.rmse","bzexp.x1.rmse","bzexp.z0.rmse","bzexp.z1.rmse","bzexp.z2.rmse",#
	"wei.x0.rmse","wei.x1.rmse","wei.p.rmse","zwei.z0.rmse","zwei.z1.rmse","zwei.z2.rmse",#
	"zwei.x0.rmse","zwei.x1.rmse","zwei.p.rmse", "bzwei.x0.rmse","bzwei.x1.rmse","bzwei.z0.rmse","bzwei.z1.rmse","bzwei.z2.rmse","bzwei.p.rmse",#
	"cox.x1.cp","exp.x0.cp","exp.x1.cp","zexp.z0.cp","zexp.z1.cp","zexp.z2.cp","zexp.x0.cp","zexp.x1.cp","bzexp.x0.cp","bzexp.x1.cp","bzexp.z0.cp","bzexp.z1.cp","bzexp.z2.cp",#
	"wei.x0.cp","wei.x1.cp","wei.p.cp",#
	"zwei.z0.cp","zwei.z1.cp","zwei.z2.cp","zwei.x0.cp","zwei.x1.cp","zwei.p.cp", "bzwei.x0.cp","bzwei.x1.cp","bzwei.z0.cp","bzwei.z1.cp","bzwei.z2.cp","bzwei.p.cp")
main.data
####
###1. Store True values for X0, X1, Z0, Z1, Z2, P#
###2. Store proportion censored pre & post#
###3. Simmulate n of 1000, do this 1000 times#
###4. Estimate cox, weibull, store all relevant coefficient estimates (exponentiate p's where applicable)#
###5. For each value in 4, calculate CPs and RMSEs, store.#
###6. Estimate zombie exp and zombie weibull-->store all relevant coefficient estimates (exponentiate p's where applicable).#
###7. For each value in 6, calculate CPs and RMSEs, store.#
###8. Estimate Bayesian zombie exp and Bayesian zombie weibull-->store all relevant coefficient estimates (exponentiate p's where applicable).#
###9. For each value in 8, calculate CPs and RMSEs, store.#
###############
####Set Up#####
###############
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(3)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-1#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
#create a dependent variable, begin the simmulations#
for(i in 1:nsims){#
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
#combine matrices and label variables#
main.data<-cbind(tru.est, cox.est, exp.est, weib.est, cox.rmse, exp.rmse, weib.rmse, cox.cp, exp.cp, weib.cp)#
colnames(main.data)<-c("true.x0","true.x1","true.z0","true.z1","true.z2","true.p","cen.lat","cen.obs",#
	"cox.x1","cox.x1.se",#
	"exp.x0","exp.x0.se","exp.x1","exp.x1.se",#
	"zexp.z0","zexp.z0.se","zexp.z1","zexp.z1.se","zexp.z2","zexp.z2.se","zexp.x0","zexp.x0.se","zexp.x1","zexp.x1.se",#
	"bzexp.x0","zexp.x0.se","bzexp.x1","bzexp.x1.se","bzexp.z0","bzexp.z0.se","bzexp.z1","bzexp.z1.se","bzexp.z2","bzexp.z2.se",#
	"wei.x0","wei.x0.se","wei.x1","wei.x1.se","wei.p","wei.p.se",#
	"zwei.z0","zwei.z0.se","zwei.z1","zwei.z1.se","zwei.z2","zwei.z2.se","zwei.x0","zwei.x0.se","zwei.x1","zwei.x1.se","zwei.p","zwei.p.se",#
	"bzwei.x0","bzwei.x0.se","bzwei.x1","bzwei.x1.se","bzwei.z0","bzwei.z0.se","bzwei.z1","bzwei.z1.se","bzwei.z2","bzwei.z2.se","bzwei.p","bzwei.p.se",#
	"cox.x1.rmse",#
	"exp.x0.rmse","exp.x1.rmse","zexp.z0.rmse","zexp.z1.rmse","zexp.z2.rmse","zexp.x0.rmse","zexp.x1.rmse","bzexp.x0.rmse","bzexp.x1.rmse","bzexp.z0.rmse","bzexp.z1.rmse","bzexp.z2.rmse",#
	"wei.x0.rmse","wei.x1.rmse","wei.p.rmse","zwei.z0.rmse","zwei.z1.rmse","zwei.z2.rmse",#
	"zwei.x0.rmse","zwei.x1.rmse","zwei.p.rmse", "bzwei.x0.rmse","bzwei.x1.rmse","bzwei.z0.rmse","bzwei.z1.rmse","bzwei.z2.rmse","bzwei.p.rmse",#
	"cox.x1.cp","exp.x0.cp","exp.x1.cp","zexp.z0.cp","zexp.z1.cp","zexp.z2.cp","zexp.x0.cp","zexp.x1.cp","bzexp.x0.cp","bzexp.x1.cp","bzexp.z0.cp","bzexp.z1.cp","bzexp.z2.cp",#
	"wei.x0.cp","wei.x1.cp","wei.p.cp",#
	"zwei.z0.cp","zwei.z1.cp","zwei.z2.cp","zwei.x0.cp","zwei.x1.cp","zwei.p.cp", "bzwei.x0.cp","bzwei.x1.cp","bzwei.z0.cp","bzwei.z1.cp","bzwei.z2.cp","bzwei.p.cp")
main.data
weib.est
main.dat
main.data
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-10#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
#create a dependent variable, begin the simmulations#
for(i in 1:nsims){#
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
#combine matrices and label variables#
main.data<-cbind(tru.est, cox.est, exp.est, weib.est, cox.rmse, exp.rmse, weib.rmse, cox.cp, exp.cp, weib.cp)#
colnames(main.data)<-c("true.x0","true.x1","true.z0","true.z1","true.z2","true.p","cen.lat","cen.obs",#
	"cox.x1","cox.x1.se",#
	"exp.x0","exp.x0.se","exp.x1","exp.x1.se",#
	"zexp.z0","zexp.z0.se","zexp.z1","zexp.z1.se","zexp.z2","zexp.z2.se","zexp.x0","zexp.x0.se","zexp.x1","zexp.x1.se",#
	"bzexp.x0","zexp.x0.se","bzexp.x1","bzexp.x1.se","bzexp.z0","bzexp.z0.se","bzexp.z1","bzexp.z1.se","bzexp.z2","bzexp.z2.se",#
	"wei.x0","wei.x0.se","wei.x1","wei.x1.se","wei.p","wei.p.se",#
	"zwei.z0","zwei.z0.se","zwei.z1","zwei.z1.se","zwei.z2","zwei.z2.se","zwei.x0","zwei.x0.se","zwei.x1","zwei.x1.se","zwei.p","zwei.p.se",#
	"bzwei.x0","bzwei.x0.se","bzwei.x1","bzwei.x1.se","bzwei.z0","bzwei.z0.se","bzwei.z1","bzwei.z1.se","bzwei.z2","bzwei.z2.se","bzwei.p","bzwei.p.se",#
	"cox.x1.rmse",#
	"exp.x0.rmse","exp.x1.rmse","zexp.z0.rmse","zexp.z1.rmse","zexp.z2.rmse","zexp.x0.rmse","zexp.x1.rmse","bzexp.x0.rmse","bzexp.x1.rmse","bzexp.z0.rmse","bzexp.z1.rmse","bzexp.z2.rmse",#
	"wei.x0.rmse","wei.x1.rmse","wei.p.rmse","zwei.z0.rmse","zwei.z1.rmse","zwei.z2.rmse",#
	"zwei.x0.rmse","zwei.x1.rmse","zwei.p.rmse", "bzwei.x0.rmse","bzwei.x1.rmse","bzwei.z0.rmse","bzwei.z1.rmse","bzwei.z2.rmse","bzwei.p.rmse",#
	"cox.x1.cp","exp.x0.cp","exp.x1.cp","zexp.z0.cp","zexp.z1.cp","zexp.z2.cp","zexp.x0.cp","zexp.x1.cp","bzexp.x0.cp","bzexp.x1.cp","bzexp.z0.cp","bzexp.z1.cp","bzexp.z2.cp",#
	"wei.x0.cp","wei.x1.cp","wei.p.cp",#
	"zwei.z0.cp","zwei.z1.cp","zwei.z2.cp","zwei.x0.cp","zwei.x1.cp","zwei.p.cp", "bzwei.x0.cp","bzwei.x1.cp","bzwei.z0.cp","bzwei.z1.cp","bzwei.z2.cp","bzwei.p.cp")
main.data
colMeans(main.data)
colMeans(main.data, na.rm = TRUE)
main.data
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Regular DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(3)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-10#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
#create a dependent variable, begin the simmulations#
for(i in 1:nsims){#
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<-Inf#
tru.est[i,4]<-Inf#
tru.est[i,5]<-Inf#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
#combine matrices and label variables#
main.data<-cbind(tru.est,cox.est,exp.est,weib.est,cox.rmse,exp.rmse,weib.rmse,cox.cp,exp.cp,weib.cp)#
colnames(main.data)<-c("true.x0","true.x1","true.z0","true.z1","true.z2","true.p","cen.lat","cen.obs",#
	"cox.x1","cox.x1.se",#
	"exp.x0","exp.x0.se","exp.x1","exp.x1.se",#
	"zexp.z0","zexp.z0.se","zexp.z1","zexp.z1.se","zexp.z2","zexp.z2.se","zexp.x0","zexp.x0.se","zexp.x1","zexp.x1.se",#
	"bzexp.x0","zexp.x0.se","bzexp.x1","bzexp.x1.se","bzexp.z0","bzexp.z0.se","bzexp.z1","bzexp.z1.se","bzexp.z2","bzexp.z2.se",#
	"wei.x0","wei.x0.se","wei.x1","wei.x1.se","wei.p","wei.p.se",#
	"zwei.z0","zwei.z0.se","zwei.z1","zwei.z1.se","zwei.z2","zwei.z2.se","zwei.x0","zwei.x0.se","zwei.x1","zwei.x1.se","zwei.p","zwei.p.se",#
	"bzwei.x0","bzwei.x0.se","bzwei.x1","bzwei.x1.se","bzwei.z0","bzwei.z0.se","bzwei.z1","bzwei.z1.se","bzwei.z2","bzwei.z2.se","bzwei.p","bzwei.p.se",#
	"cox.x1.rmse",#
	"exp.x0.rmse","exp.x1.rmse","zexp.z0.rmse","zexp.z1.rmse","zexp.z2.rmse","zexp.x0.rmse","zexp.x1.rmse","bzexp.x0.rmse","bzexp.x1.rmse","bzexp.z0.rmse","bzexp.z1.rmse","bzexp.z2.rmse",#
	"wei.x0.rmse","wei.x1.rmse","wei.p.rmse","zwei.z0.rmse","zwei.z1.rmse","zwei.z2.rmse",#
	"zwei.x0.rmse","zwei.x1.rmse","zwei.p.rmse", "bzwei.x0.rmse","bzwei.x1.rmse","bzwei.z0.rmse","bzwei.z1.rmse","bzwei.z2.rmse","bzwei.p.rmse",#
	"cox.x1.cp","exp.x0.cp","exp.x1.cp","zexp.z0.cp","zexp.z1.cp","zexp.z2.cp","zexp.x0.cp","zexp.x1.cp","bzexp.x0.cp","bzexp.x1.cp","bzexp.z0.cp","bzexp.z1.cp","bzexp.z2.cp",#
	"wei.x0.cp","wei.x1.cp","wei.p.cp",#
	"zwei.z0.cp","zwei.z1.cp","zwei.z2.cp","zwei.x0.cp","zwei.x1.cp","zwei.p.cp", "bzwei.x0.cp","bzwei.x1.cp","bzwei.z0.cp","bzwei.z1.cp","bzwei.z2.cp","bzwei.p.cp")#
#save dataset#
main.data<-as.data.frame(main.data)
main.data
colMeans(main.data, na.rm = TRUE)
plot(BayesZWeibull$gammas[,1], type = 'l')
plot(BayesZWeibull$gammas[,2], type = 'l')
plot(BayesZWeibull$gammas[,3], type = 'l')
plot(BayesZExponential$gammas[,3], type = 'l')
plot(BayesZExponential$gammas[,2], type = 'l')
plot(BayesZExponential$gammas[,1], type = 'l')
1 / (1 + exp(-Inf))
C
Results<-read.dta("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/main.data.dta")
#clear memory  #
rm(list=ls())                                           #
library(car)#
library(Hmisc)                                                     #
library(mvtnorm)#
library(foreign)#
library(graphics)#
library(MASS)#
library(lattice)#
library(tseries)#
library(Matrix)#
library(Design)#
library(msm)#
library(corpcor)#
library(Zelig)#
Results<-read.dta("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/main.data.dta")#
Results<-as.matrix(Results)#
resize.win <- function(Width=6, Height=6)#
{#
        # works for windows#
    dev.off(); # dev.new(width=6, height=6)#
    windows(record=TRUE, width=Width, height=Height)#
}#
resize.win(7,4)#
par(mfrow=c(2,3))#
par(cex.lab=1)#
par(cex.axis=1)#
par(cex.main=1)#
par(mar=c(5.1,4.1,2.1,2.1))#
#sets the bottom, left, top and right #
#B0#
local.xlim<-c(.53,1.68)#
local.ylim<-c(0,7)#
plot(density(Results[,11],na.rm=TRUE), main = "",  ylab = "", xlab = "", xlim=local.xlim, ylim=local.ylim,col="blue", xaxt='n', yaxt='n')#
abline(v=1,lty=3)#
par(new=TRUE)#
plot(density(Results[,21],na.rm=TRUE), main = "",  ylab = "", xlab = "",xlim=local.xlim, ylim=local.ylim,col="red", xaxt='n', yaxt='n')#
par(new=TRUE)#
plot(density(Results[,25],na.rm=TRUE), main = "",  ylab = "", xlab = "",xlim=local.xlim, ylim=local.ylim,col="forestgreen", xaxt='n', yaxt='n')#
par(new=TRUE)#
plot(density(Results[,37],na.rm=TRUE), main = "", xlab = "Beta 0",xlim=local.xlim, ylim=local.ylim,col="purple")#
text (x=.7, y =6.72, "Z.Exp",col="red")#
text (x=.84, y =6.72, "/",col="black")#
text (x=.75, y =6.08, "Z.Wei",col="purple")#
text (x=1.33, y =6.7, "Exp",col="blue")#
text (x=1.5, y =5.5, "Wei",col="forestgreen")#
par(new=FALSE)
#B1#
local.xlim<-c(3.40,3.6)#
local.ylim<-c(0,46.5)#
plot(density(Results[,13],na.rm=TRUE), main = "",  ylab = "", xlab = "", xlim=local.xlim, ylim=local.ylim,col="blue", xaxt='n', yaxt='n')#
abline(v=3.5,lty=3)#
par(new=TRUE)#
plot(density(Results[,23],na.rm=TRUE), main = "", ylab = "",  xlab = "",xlim=local.xlim, ylim=local.ylim,col="red", xaxt='n', yaxt='n')#
par(new=TRUE)#
plot(density(Results[,27],na.rm=TRUE), main = "",  ylab = "", xlab = "",xlim=local.xlim, ylim=local.ylim,col="forestgreen", xaxt='n', yaxt='n')#
par(new=TRUE)#
plot(density(Results[,39],na.rm=TRUE), main = "", xlab = "Beta 1",xlim=local.xlim, ylim=local.ylim,col="purple")#
text (x=3.533, y =42, "Z.Exp",col="red")#
text (x=3.558, y =42, "/",col="black")#
text (x=3.58, y =42, "Z.Wei",col="purple")#
text (x=3.410, y =42, "Exp",col="blue")#
text (x=3.427, y =42, "/",col="black")#
text (x=3.445, y =42, "Wei",col="forestgreen")#
par(new=FALSE)#
#B1#
local.ylim<-c(0,20)#
local.xlim<-c(0.75,1.1)#
plot(density(Results[,29],na.rm=TRUE), main = "",  ylab = "", xlab = "",xlim=local.xlim, ylim=local.ylim,col="forestgreen", xaxt='n', yaxt='n')#
abline(v=1,lty=3)#
par(new=TRUE)#
plot(density(Results[,41],na.rm=TRUE), main = "", xlab = "P",xlim=local.xlim, ylim=local.ylim,col="purple")#
text (x=1.06, y =15.2, "Z.Wei",col="purple")#
text (x=.85, y =19, "Wei",col="forestgreen")#
par(new=FALSE)#
#B1#
local.ylim<-c(0,.6)#
local.xlim<-c(-5.3,2)#
plot(density(Results[,15],na.rm=TRUE), main = "", ylab = "", xlab = "",xlim=local.xlim, ylim=local.ylim,col="red", xaxt='n', yaxt='n')#
abline(v=-2,lty=3)#
par(new=TRUE)#
plot(density(Results[,31],na.rm=TRUE), main = "", xlab = "Gamma 0",xlim=local.xlim, ylim=local.ylim,col="purple")#
text (x=-1, y =.38, "Z.Exp",col="red")#
text (x=-.1, y =.38, "/",col="black")#
text (x=.96, y =.38, "Z.Wei",col="purple")#
par(new=FALSE)#
#B1#
local.ylim<-c(0,1)#
local.xlim<-c(.5,4.4)#
plot(density(Results[,17],na.rm=TRUE), main = "", ylab = "",  xlab = "",xlim=local.xlim, ylim=local.ylim,col="red", xaxt='n', yaxt='n')#
abline(v=2,lty=3)#
par(new=TRUE)#
plot(density(Results[,33],na.rm=TRUE), main = "", xlab = "Gamma 1",xlim=local.xlim, ylim=local.ylim,col="purple")#
text (x=2.55, y =.86, "Z.Exp",col="red")#
text (x=3.05, y =.86, "/",col="black")#
text (x=3.55, y =.86, "Z.Wei",col="purple")#
par(new=FALSE)#
#B1#
local.ylim<-c(0,1)#
local.xlim<-c(1.5,6.5)#
plot(density(Results[,19],na.rm=TRUE), main = "", ylab = "",  xlab = "",xlim=local.xlim, ylim=local.ylim,col="red", xaxt='n', yaxt='n')#
abline(v=3,lty=3)#
par(new=TRUE)#
plot(density(Results[,35],na.rm=TRUE), main = "", xlab = "Gamma 2",xlim=local.xlim, ylim=local.ylim,col="purple")#
text (x=4.1, y =.6, "Z.Exp",col="red")#
text (x=4.7, y =.6, "/",col="black")#
text (x=5.4, y =.6, "Z.Wei",col="purple")#
par(new=FALSE)
main.data
