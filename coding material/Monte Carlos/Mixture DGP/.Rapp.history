burn = 1000
thin = 20
w = c(1, 1, 1)
m = 10
form = "Weibull"
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
#
  # initial values#
  #Sigma.b = 10 * p1 * diag(p1)  # multiply 10 to ensure large enough variance in the early stages#
  #Sigma.g = 10 * p2 * diag(p2)  # multiply 10 to ensure large enough variance in the early stages#
  betas = rep(0, p1)#
  gammas = rep(0, p2)#
  lambda = 1#
  alpha = 1 / (1 + exp(-Z %*% gammas))#
#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  gammas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p2)#
  lambda.samp = rep(NA, (N - burn) / thin)#
  for (iter in 1:N) {#
    if (iter %% 1000 == 0) print(iter)#
    Sigma.b = riwish(1 + p1, betas %*% t(betas) + p1 * diag(p1))#
    Sigma.g = riwish(1 + p2, gammas %*% t(gammas) + p2 * diag(p2))#
    betas = betas.slice.sampling(Sigma.b, Y, X, betas, alpha, C, lambda, w[1], m)#
    eXB = exp(X %*% betas)#
    gammas = gammas.slice.sampling(Sigma.g, Y, eXB, Z, gammas, C, lambda, w[2], m)#
    alpha = 1 / (1 + exp(-Z %*% gammas))#
    if (form %in% "Weibull") {#
    lambda = lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)#
     } #
    if (iter > burn & (iter - burn) %% thin == 0) {#
      betas.samp[(iter - burn) / thin, ] = betas#
      gammas.samp[(iter - burn) / thin, ] = gammas#
      lambda.samp[(iter - burn) / thin] = lambda#
    }#
  }
form = "Exponential"
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
#
  # initial values#
  #Sigma.b = 10 * p1 * diag(p1)  # multiply 10 to ensure large enough variance in the early stages#
  #Sigma.g = 10 * p2 * diag(p2)  # multiply 10 to ensure large enough variance in the early stages#
  betas = rep(0, p1)#
  gammas = rep(0, p2)#
  lambda = 1#
  alpha = 1 / (1 + exp(-Z %*% gammas))#
#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  gammas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p2)#
  lambda.samp = rep(NA, (N - burn) / thin)#
  for (iter in 1:N) {#
    if (iter %% 1000 == 0) print(iter)#
    Sigma.b = riwish(1 + p1, betas %*% t(betas) + p1 * diag(p1))#
    Sigma.g = riwish(1 + p2, gammas %*% t(gammas) + p2 * diag(p2))#
    betas = betas.slice.sampling(Sigma.b, Y, X, betas, alpha, C, lambda, w[1], m)#
    eXB = exp(X %*% betas)#
    gammas = gammas.slice.sampling(Sigma.g, Y, eXB, Z, gammas, C, lambda, w[2], m)#
    alpha = 1 / (1 + exp(-Z %*% gammas))#
    if (form %in% "Weibull") {#
    lambda = lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)#
     } #
    if (iter > burn & (iter - burn) %% thin == 0) {#
      betas.samp[(iter - burn) / thin, ] = betas#
      gammas.samp[(iter - burn) / thin, ] = gammas#
      lambda.samp[(iter - burn) / thin] = lambda#
    }#
  }
####
###1. Store True values for X0, X1, Z0, Z1, Z2, P#
###2. Store proportion censored pre & post#
###3. Simmulate n of 1000, do this 1000 times#
###4. Estimate cox, weibull, store all relevant coefficient estimates (exponentiate p's where applicable)#
###5. For each value in 4, calculate CPs and RMSEs, store.#
###6. Estimate zombie exp and zombie weibull-->store all relevant coefficient estimates (exponentiate p's where applicable).#
###7. For each value in 6, calculate CPs and RMSEs, store.#
###8. Estimate Bayesian zombie exp and Bayesian zombie weibull-->store all relevant coefficient estimates (exponentiate p's where applicable).#
###9. For each value in 8, calculate CPs and RMSEs, store.#
###############
####Set Up#####
###############
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(3)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-8#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
#create a dependent variable, begin the simmulations#
for(i in 1:nsims){#
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
print("hi")#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
#combine matrices and label variables#
main.data<-cbind(tru.est, cox.est, exp.est, weib.est, cox.rmse, exp.rmse, weib.rmse, cox.cp, exp.cp, weib.cp)#
colnames(main.data)<-c("true.x0","true.x1","true.z0","true.z1","true.z2","true.p","cen.lat","cen.obs",#
	"cox.x1","cox.x1.se",#
	"exp.x0","exp.x0.se","exp.x1","exp.x1.se",#
	"zexp.z0","zexp.z0.se","zexp.z1","zexp.z1.se","zexp.z2","zexp.z2.se","zexp.x0","zexp.x0.se","zexp.x1","zexp.x1.se",#
	"bzexp.x0","zexp.x0.se","bzexp.x1","bzexp.x1.se","bzexp.z0","bzexp.z0.se","bzexp.z1","bzexp.z1.se","bzexp.z2","bzexp.z2.se",#
	"wei.x0","wei.x0.se","wei.x1","wei.x1.se","wei.p","wei.p.se",#
	"zwei.z0","zwei.z0.se","zwei.z1","zwei.z1.se","zwei.z2","zwei.z2.se","zwei.x0","zwei.x0.se","zwei.x1","zwei.x1.se","zwei.p","zwei.p.se",#
	"bzwei.x0","bzwei.x0.se","bzwei.x1","bzwei.x1.se","bzwei.z0","bzwei.z0.se","bzwei.z1","bzwei.z1.se","bzwei.z2","bzwei.z2.se","bzwei.p","bzwei.p.se",#
	"cox.x1.rmse",#
	"exp.x0.rmse","exp.x1.rmse","zexp.z0.rmse","zexp.z1.rmse","zexp.z2.rmse","zexp.x0.rmse","zexp.x1.rmse","bzexp.x0.rmse","bzexp.x1.rmse","bzexp.z0.rmse","bzexp.z1.rmse","bzexp.z2.rmse",#
	"wei.x0.rmse","wei.x1.rmse","wei.p.rmse","zwei.z0.rmse","zwei.z1.rmse","zwei.z2.rmse",#
	"zwei.x0.rmse","zwei.x1.rmse","zwei.p.rmse", "bzwei.x0.rmse","bzwei.x1.rmse","bzwei.z0.rmse","bzwei.z1.rmse","bzwei.z2.rmse","bzwei.p.rmse",#
	"cox.x1.cp","exp.x0.cp","exp.x1.cp","zexp.z0.cp","zexp.z1.cp","zexp.z2.cp","zexp.x0.cp","zexp.x1.cp","bzexp.x0.cp","bzexp.x1.cp","bzexp.z0.cp","bzexp.z1.cp","bzexp.z2.cp",#
	"wei.x0.cp","wei.x1.cp","wei.p.cp",#
	"zwei.z0.cp","zwei.z1.cp","zwei.z2.cp","zwei.x0.cp","zwei.x1.cp","zwei.p.cp", "bzwei.x0.cp","bzwei.x1.cp","bzwei.z0.cp","bzwei.z1.cp","bzwei.z2.cp","bzwei.p.cp")#
#save dataset#
main.data2<-as.data.frame(main.data)
래그
form
form = "Weibull"
N = 3000
burn = 1000
thin = 20
w = c(1,1,1)
m = 10
mcmcOF<- function(Y, C, X, Z, N, burn, thin, w = c(1, 1, 1), m = 10, form) {#
  p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
#
  # initial values#
  #Sigma.b = 10 * p1 * diag(p1)  # multiply 10 to ensure large enough variance in the early stages#
  #Sigma.g = 10 * p2 * diag(p2)  # multiply 10 to ensure large enough variance in the early stages#
  betas = rep(0, p1)#
  gammas = rep(0, p2)#
  lambda = 1#
  alpha = 1 / (1 + exp(-Z %*% gammas))#
#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  gammas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p2)#
  lambda.samp = rep(NA, (N - burn) / thin)#
  for (iter in 1:N) {#
    if (iter %% 1000 == 0) print(iter)#
    Sigma.b = riwish(1 + p1, betas %*% t(betas) + p1 * diag(p1))#
    Sigma.g = riwish(1 + p2, gammas %*% t(gammas) + p2 * diag(p2))#
    betas = betas.slice.sampling(Sigma.b, Y, X, betas, alpha, C, lambda, w[1], m)#
    eXB = exp(X %*% betas)#
    gammas = gammas.slice.sampling(Sigma.g, Y, eXB, Z, gammas, C, lambda, w[2], m)#
    alpha = 1 / (1 + exp(-Z %*% gammas))#
    if (form %in% "Weibull") {#
    lambda = lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)#
     } #
    if (iter > burn & (iter - burn) %% thin == 0) {#
      betas.samp[(iter - burn) / thin, ] = betas#
      gammas.samp[(iter - burn) / thin, ] = gammas#
      lambda.samp[(iter - burn) / thin] = lambda#
    }#
  }#
  return(list(betas = betas.samp, gammas = gammas.samp, lambda = lambda.samp))#
}
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(3)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-8
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)
nsims
for(i in 1:nsims){#
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
}
y
print("hi")#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(300)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-1000#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
#create a dependent variable, begin the simmulations#
for(i in 1:nsims){#
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
print("hi")#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
#combine matrices and label variables#
main.data<-cbind(tru.est, cox.est, exp.est, weib.est, cox.rmse, exp.rmse, weib.rmse, cox.cp, exp.cp, weib.cp)#
colnames(main.data)<-c("true.x0","true.x1","true.z0","true.z1","true.z2","true.p","cen.lat","cen.obs",#
	"cox.x1","cox.x1.se",#
	"exp.x0","exp.x0.se","exp.x1","exp.x1.se",#
	"zexp.z0","zexp.z0.se","zexp.z1","zexp.z1.se","zexp.z2","zexp.z2.se","zexp.x0","zexp.x0.se","zexp.x1","zexp.x1.se",#
	"bzexp.x0","zexp.x0.se","bzexp.x1","bzexp.x1.se","bzexp.z0","bzexp.z0.se","bzexp.z1","bzexp.z1.se","bzexp.z2","bzexp.z2.se",#
	"wei.x0","wei.x0.se","wei.x1","wei.x1.se","wei.p","wei.p.se",#
	"zwei.z0","zwei.z0.se","zwei.z1","zwei.z1.se","zwei.z2","zwei.z2.se","zwei.x0","zwei.x0.se","zwei.x1","zwei.x1.se","zwei.p","zwei.p.se",#
	"bzwei.x0","bzwei.x0.se","bzwei.x1","bzwei.x1.se","bzwei.z0","bzwei.z0.se","bzwei.z1","bzwei.z1.se","bzwei.z2","bzwei.z2.se","bzwei.p","bzwei.p.se",#
	"cox.x1.rmse",#
	"exp.x0.rmse","exp.x1.rmse","zexp.z0.rmse","zexp.z1.rmse","zexp.z2.rmse","zexp.x0.rmse","zexp.x1.rmse","bzexp.x0.rmse","bzexp.x1.rmse","bzexp.z0.rmse","bzexp.z1.rmse","bzexp.z2.rmse",#
	"wei.x0.rmse","wei.x1.rmse","wei.p.rmse","zwei.z0.rmse","zwei.z1.rmse","zwei.z2.rmse",#
	"zwei.x0.rmse","zwei.x1.rmse","zwei.p.rmse", "bzwei.x0.rmse","bzwei.x1.rmse","bzwei.z0.rmse","bzwei.z1.rmse","bzwei.z2.rmse","bzwei.p.rmse",#
	"cox.x1.cp","exp.x0.cp","exp.x1.cp","zexp.z0.cp","zexp.z1.cp","zexp.z2.cp","zexp.x0.cp","zexp.x1.cp","bzexp.x0.cp","bzexp.x1.cp","bzexp.z0.cp","bzexp.z1.cp","bzexp.z2.cp",#
	"wei.x0.cp","wei.x1.cp","wei.p.cp",#
	"zwei.z0.cp","zwei.z1.cp","zwei.z2.cp","zwei.x0.cp","zwei.x1.cp","zwei.p.cp", "bzwei.x0.cp","bzwei.x1.cp","bzwei.z0.cp","bzwei.z1.cp","bzwei.z2.cp","bzwei.p.cp")#
#save dataset#
main.data2<-as.data.frame(main.data)
nsims = 1
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(300)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-1000#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
#create a dependent variable, begin the simmulations#
for(i in 1:nsims){#
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
#combine matrices and label variables#
main.data<-cbind(tru.est, cox.est, exp.est, weib.est, cox.rmse, exp.rmse, weib.rmse, cox.cp, exp.cp, weib.cp)#
colnames(main.data)<-c("true.x0","true.x1","true.z0","true.z1","true.z2","true.p","cen.lat","cen.obs",#
	"cox.x1","cox.x1.se",#
	"exp.x0","exp.x0.se","exp.x1","exp.x1.se",#
	"zexp.z0","zexp.z0.se","zexp.z1","zexp.z1.se","zexp.z2","zexp.z2.se","zexp.x0","zexp.x0.se","zexp.x1","zexp.x1.se",#
	"bzexp.x0","zexp.x0.se","bzexp.x1","bzexp.x1.se","bzexp.z0","bzexp.z0.se","bzexp.z1","bzexp.z1.se","bzexp.z2","bzexp.z2.se",#
	"wei.x0","wei.x0.se","wei.x1","wei.x1.se","wei.p","wei.p.se",#
	"zwei.z0","zwei.z0.se","zwei.z1","zwei.z1.se","zwei.z2","zwei.z2.se","zwei.x0","zwei.x0.se","zwei.x1","zwei.x1.se","zwei.p","zwei.p.se",#
	"bzwei.x0","bzwei.x0.se","bzwei.x1","bzwei.x1.se","bzwei.z0","bzwei.z0.se","bzwei.z1","bzwei.z1.se","bzwei.z2","bzwei.z2.se","bzwei.p","bzwei.p.se",#
	"cox.x1.rmse",#
	"exp.x0.rmse","exp.x1.rmse","zexp.z0.rmse","zexp.z1.rmse","zexp.z2.rmse","zexp.x0.rmse","zexp.x1.rmse","bzexp.x0.rmse","bzexp.x1.rmse","bzexp.z0.rmse","bzexp.z1.rmse","bzexp.z2.rmse",#
	"wei.x0.rmse","wei.x1.rmse","wei.p.rmse","zwei.z0.rmse","zwei.z1.rmse","zwei.z2.rmse",#
	"zwei.x0.rmse","zwei.x1.rmse","zwei.p.rmse", "bzwei.x0.rmse","bzwei.x1.rmse","bzwei.z0.rmse","bzwei.z1.rmse","bzwei.z2.rmse","bzwei.p.rmse",#
	"cox.x1.cp","exp.x0.cp","exp.x1.cp","zexp.z0.cp","zexp.z1.cp","zexp.z2.cp","zexp.x0.cp","zexp.x1.cp","bzexp.x0.cp","bzexp.x1.cp","bzexp.z0.cp","bzexp.z1.cp","bzexp.z2.cp",#
	"wei.x0.cp","wei.x1.cp","wei.p.cp",#
	"zwei.z0.cp","zwei.z1.cp","zwei.z2.cp","zwei.x0.cp","zwei.x1.cp","zwei.p.cp", "bzwei.x0.cp","bzwei.x1.cp","bzwei.z0.cp","bzwei.z1.cp","bzwei.z2.cp","bzwei.p.cp")#
#save dataset#
main.data2<-as.data.frame(main.data)
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(300)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-1#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
#create a dependent variable, begin the simmulations#
for(i in 1:nsims){#
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
#combine matrices and label variables#
main.data<-cbind(tru.est, cox.est, exp.est, weib.est, cox.rmse, exp.rmse, weib.rmse, cox.cp, exp.cp, weib.cp)#
colnames(main.data)<-c("true.x0","true.x1","true.z0","true.z1","true.z2","true.p","cen.lat","cen.obs",#
	"cox.x1","cox.x1.se",#
	"exp.x0","exp.x0.se","exp.x1","exp.x1.se",#
	"zexp.z0","zexp.z0.se","zexp.z1","zexp.z1.se","zexp.z2","zexp.z2.se","zexp.x0","zexp.x0.se","zexp.x1","zexp.x1.se",#
	"bzexp.x0","zexp.x0.se","bzexp.x1","bzexp.x1.se","bzexp.z0","bzexp.z0.se","bzexp.z1","bzexp.z1.se","bzexp.z2","bzexp.z2.se",#
	"wei.x0","wei.x0.se","wei.x1","wei.x1.se","wei.p","wei.p.se",#
	"zwei.z0","zwei.z0.se","zwei.z1","zwei.z1.se","zwei.z2","zwei.z2.se","zwei.x0","zwei.x0.se","zwei.x1","zwei.x1.se","zwei.p","zwei.p.se",#
	"bzwei.x0","bzwei.x0.se","bzwei.x1","bzwei.x1.se","bzwei.z0","bzwei.z0.se","bzwei.z1","bzwei.z1.se","bzwei.z2","bzwei.z2.se","bzwei.p","bzwei.p.se",#
	"cox.x1.rmse",#
	"exp.x0.rmse","exp.x1.rmse","zexp.z0.rmse","zexp.z1.rmse","zexp.z2.rmse","zexp.x0.rmse","zexp.x1.rmse","bzexp.x0.rmse","bzexp.x1.rmse","bzexp.z0.rmse","bzexp.z1.rmse","bzexp.z2.rmse",#
	"wei.x0.rmse","wei.x1.rmse","wei.p.rmse","zwei.z0.rmse","zwei.z1.rmse","zwei.z2.rmse",#
	"zwei.x0.rmse","zwei.x1.rmse","zwei.p.rmse", "bzwei.x0.rmse","bzwei.x1.rmse","bzwei.z0.rmse","bzwei.z1.rmse","bzwei.z2.rmse","bzwei.p.rmse",#
	"cox.x1.cp","exp.x0.cp","exp.x1.cp","zexp.z0.cp","zexp.z1.cp","zexp.z2.cp","zexp.x0.cp","zexp.x1.cp","bzexp.x0.cp","bzexp.x1.cp","bzexp.z0.cp","bzexp.z1.cp","bzexp.z2.cp",#
	"wei.x0.cp","wei.x1.cp","wei.p.cp",#
	"zwei.z0.cp","zwei.z1.cp","zwei.z2.cp","zwei.x0.cp","zwei.x1.cp","zwei.p.cp", "bzwei.x0.cp","bzwei.x1.cp","bzwei.z0.cp","bzwei.z1.cp","bzwei.z2.cp","bzwei.p.cp")#
#save dataset#
main.data2<-as.data.frame(main.data)
i = 2
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)
nsims = 2
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(300)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-2#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))
i
i = 1
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)
i = 2
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)
N = 3000
burn = 1000
thin = 20
w = c(1,1,1)
m = 10
form = "Weibull"
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
#
  # initial values#
  #Sigma.b = 10 * p1 * diag(p1)  # multiply 10 to ensure large enough variance in the early stages#
  #Sigma.g = 10 * p2 * diag(p2)  # multiply 10 to ensure large enough variance in the early stages#
  betas = rep(0, p1)#
  gammas = rep(0, p2)#
  lambda = 1#
  alpha = 1 / (1 + exp(-Z %*% gammas))#
#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  gammas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p2)#
  lambda.samp = rep(NA, (N - burn) / thin)#
  for (iter in 1:N) {#
    if (iter %% 1000 == 0) print(iter)#
    Sigma.b = riwish(1 + p1, betas %*% t(betas) + p1 * diag(p1))#
    Sigma.g = riwish(1 + p2, gammas %*% t(gammas) + p2 * diag(p2))#
    betas = betas.slice.sampling(Sigma.b, Y, X, betas, alpha, C, lambda, w[1], m)#
    eXB = exp(X %*% betas)#
    gammas = gammas.slice.sampling(Sigma.g, Y, eXB, Z, gammas, C, lambda, w[2], m)#
    alpha = 1 / (1 + exp(-Z %*% gammas))#
    if (form %in% "Weibull") {#
    lambda = lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)#
     } #
    if (iter > burn & (iter - burn) %% thin == 0) {#
      betas.samp[(iter - burn) / thin, ] = betas#
      gammas.samp[(iter - burn) / thin, ] = gammas#
      lambda.samp[(iter - burn) / thin] = lambda#
    }#
  }
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")
Y
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)
Y
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(300)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-2#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))
i
i = 1
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)
i = 2
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)
data
Y
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")
N = 3000
burn = 1000
thin = 20
w = c(1, 1, 1)
m = 10
form = "Weibull"
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
#
  # initial values#
  #Sigma.b = 10 * p1 * diag(p1)  # multiply 10 to ensure large enough variance in the early stages#
  #Sigma.g = 10 * p2 * diag(p2)  # multiply 10 to ensure large enough variance in the early stages#
  betas = rep(0, p1)#
  gammas = rep(0, p2)#
  lambda = 1#
  alpha = 1 / (1 + exp(-Z %*% gammas))#
#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  gammas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p2)#
  lambda.samp = rep(NA, (N - burn) / thin)#
  for (iter in 1:N) {#
    if (iter %% 1000 == 0) print(iter)#
    Sigma.b = riwish(1 + p1, betas %*% t(betas) + p1 * diag(p1))#
    Sigma.g = riwish(1 + p2, gammas %*% t(gammas) + p2 * diag(p2))#
    betas = betas.slice.sampling(Sigma.b, Y, X, betas, alpha, C, lambda, w[1], m)#
    eXB = exp(X %*% betas)#
    gammas = gammas.slice.sampling(Sigma.g, Y, eXB, Z, gammas, C, lambda, w[2], m)#
    alpha = 1 / (1 + exp(-Z %*% gammas))#
    if (form %in% "Weibull") {#
    lambda = lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)#
     } #
    if (iter > burn & (iter - burn) %% thin == 0) {#
      betas.samp[(iter - burn) / thin, ] = betas#
      gammas.samp[(iter - burn) / thin, ] = gammas#
      lambda.samp[(iter - burn) / thin] = lambda#
    }#
  }
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(300)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-2#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))
i = 1
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)
i = 2
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)
N = 3000
burn = 1000
thin = 20
w = c(1, 1, 1)
m = 10
form = "Weibull"
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
#
  # initial values#
  #Sigma.b = 10 * p1 * diag(p1)  # multiply 10 to ensure large enough variance in the early stages#
  #Sigma.g = 10 * p2 * diag(p2)  # multiply 10 to ensure large enough variance in the early stages#
  betas = rep(0, p1)#
  gammas = rep(0, p2)#
  lambda = 1#
  alpha = 1 / (1 + exp(-Z %*% gammas))#
#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  gammas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p2)#
  lambda.samp = rep(NA, (N - burn) / thin)
for (iter in 1:N) {#
    if (iter %% 1000 == 0) print(iter)#
    Sigma.b = riwish(1 + p1, betas %*% t(betas) + p1 * diag(p1))#
    Sigma.g = riwish(1 + p2, gammas %*% t(gammas) + p2 * diag(p2))#
    betas = betas.slice.sampling(Sigma.b, Y, X, betas, alpha, C, lambda, w[1], m)#
    eXB = exp(X %*% betas)#
    gammas = gammas.slice.sampling(Sigma.g, Y, eXB, Z, gammas, C, lambda, w[2], m)#
    alpha = 1 / (1 + exp(-Z %*% gammas))#
    if (form %in% "Weibull") {#
    lambda = lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)#
     } #
    if (iter > burn & (iter - burn) %% thin == 0) {#
      betas.samp[(iter - burn) / thin, ] = betas#
      gammas.samp[(iter - burn) / thin, ] = gammas#
      lambda.samp[(iter - burn) / thin] = lambda#
    }#
  }
eXB
gammas
betas
lambda
lambda = lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)
lambda
try
?tru
?tru
?try
try(log("a"))#
print(.Last.value)
.Last.value
try(log(0))
document()
#' @useDynLib BayesOFsurv#
#' @importFrom stats dgamma runif#
#' @import grDevices#
#' @import graphics#
#' @import RcppArmadillo#
#' @importFrom Rcpp sourceCpp#
#' @importFrom MCMCpack riwish#
#' @importFrom mvtnorm rmvnorm dmvnorm#
NULL#
#
#' @title betas.slice.sampling#
#' @description slice sampling for betas#
#'#
#' @param Sigma.b variance estimate of betas#
#' @param Y response variable#
#' @param X covariates for betas#
#' @param betas current value of betas#
#' @param alpha probability of true censoring#
#' @param C censoring indicator#
#' @param lambda current value of lambda#
#' @param w size of the slice in the slice sampling#
#' @param m limit on steps in the slice sampling#
#'#
#' @return One sample update using slice sampling#
#'#
#' @export#
betas.slice.sampling = function(Sigma.b, Y, X, betas, alpha, C, lambda, w, m) {#
  p1 = length(betas)#
  for (p in sample(1:p1, p1, replace = FALSE)) {#
    betas[p] = univ.betas.slice.sampling(betas[p], p, Sigma.b, Y, X, betas, alpha, C, lambda, w, m)#
  }#
  return(betas)#
}#
#
#' @title univ.betas.slice.sampling#
#' @description univariate slice sampling for betas.p#
#'#
#' @param betas.p current value of the pth element of betas#
#' @param p pth element#
#' @param Sigma.b variance estimate of betas#
#' @param Y response variable#
#' @param X covariates for betas#
#' @param betas current value of betas#
#' @param alpha probability of true censoring#
#' @param C censoring indicator#
#' @param lambda current value of lambda#
#' @param w size of the slice in the slice sampling#
#' @param m limit on steps in the slice sampling#
#' @param lower lower bound on support of the distribution#
#' @param upper upper bound on support of the distribution#
#'#
#' @return One sample update using slice sampling#
#'#
#' @export#
univ.betas.slice.sampling = function(betas.p, p, Sigma.b, Y, X, betas, alpha, C, lambda, w, m, lower = -Inf, upper = +Inf) {#
  b0 = betas.p#
  b.post0 = betas.post(b0, p, Sigma.b, Y, X, betas, alpha, C, lambda)#
#
  u = runif(1, 0, w)#
  L = b0 - u#
  R = b0 + (w - u)#
  if (is.infinite(m)) {#
    repeat#
    { if (L <= lower) break#
      if (betas.post(L, p, Sigma.b, Y, X, betas, alpha, C, lambda) <= b.post0) break#
      L = L - w#
    }#
    repeat#
    {#
      if (R >= upper) break#
      if (betas.post(R, p, Sigma.b, Y, X, betas, alpha, C, lambda) <= b.post0) break#
      R = R + w#
    }#
  } else if (m > 1) {#
    J = floor(runif(1, 0, m))#
    K = (m - 1) - J#
#
    while (J > 0) {#
      if (L <= lower) break#
      if (betas.post(L, p, Sigma.b, Y, X, betas, alpha, C, lambda) <= b.post0) break#
      L = L - w#
      J = J - 1#
    }#
#
    while (K > 0) {#
      if (R >= upper) break#
      if (betas.post(R, p, Sigma.b, Y, X, betas, alpha, C, lambda) <= b.post0) break#
      R = R + w#
      K = K - 1#
    }#
  }#
#
  if (L < lower) {#
    L = lower#
  }#
  if (R > upper) {#
    R = upper#
  }#
#
  repeat#
  {#
    b1 = runif(1, L, R)#
    b.post1 = betas.post(b1, p, Sigma.b, Y, X, betas, alpha, C, lambda)#
#
    if (b.post1 >= b.post0) break#
    if (b1 > b0) {#
      R = b1#
    } else {#
      L = b1#
    }#
  }#
  return(b1)#
  }#
#
#' @title gammas.slice.sampling#
#' @description slice sampling for gammas#
#'#
#' @param Sigma.g variance estimate of gammas#
#' @param Y response variable#
#' @param eXB exponentiated vector of covariates times betas#
#' @param Z covariates for gammas#
#' @param gammas current value of gammas#
#' @param C censoring indicator#
#' @param lambda current value of lambda#
#' @param w size of the slice in the slice sampling#
#' @param m limit on steps in the slice sampling#
#'#
#' @return One sample update using slice sampling#
#'#
#' @export#
gammas.slice.sampling = function(Sigma.g, Y, eXB, Z, gammas, C, lambda, w, m) {#
  p2 = length(gammas)#
  for (p in sample(1:p2, p2, replace = FALSE)) {#
    gammas[p] = univ.gammas.slice.sampling(gammas[p], p, Sigma.g, Y, eXB, Z, gammas, C, lambda, w, m)#
  }#
  return(gammas)#
}#
#
#' @title univ.gammas.slice.sampling#
#' @description univariate slice sampling for gammas.p#
#'#
#' @param gammas.p current value of the pth element of gammas#
#' @param p pth element#
#' @param Sigma.g variance estimate of gammas#
#' @param Y response variable#
#' @param eXB exponentiated vector of covariates times betas#
#' @param Z covariates for gammas#
#' @param gammas current value of gammas#
#' @param C censoring indicator#
#' @param lambda current value of lambda#
#' @param w size of the slice in the slice sampling#
#' @param m limit on steps in the slice sampling#
#' @param lower lower bound on support of the distribution#
#' @param upper upper bound on support of the distribution#
#'#
#' @return One sample update using slice sampling#
#'#
#' @export#
univ.gammas.slice.sampling = function(gammas.p, p, Sigma.g, Y, eXB, Z, gammas, C, lambda, w, m, lower = -Inf, upper = +Inf) {#
  g0 = gammas.p#
  g.post0 = gammas.post(g0, p, Sigma.g, Y, eXB, Z, gammas, C, lambda)#
#
  u = runif(1, 0, w)#
  L = g0 - u#
  R = g0 + (w - u)#
  if (is.infinite(m)) {#
    repeat#
    { if (L <= lower) break#
      if (gammas.post(L, p, Sigma.g, Y, eXB, Z, gammas, C, lambda) <= g.post0) break#
      L = L - w#
    }#
    repeat#
    {#
      if (R >= upper) break#
      if (gammas.post(R, p, Sigma.g, Y, eXB, Z, gammas, C, lambda) <= g.post0) break#
      R = R + w#
    }#
  } else if (m > 1) {#
    J = floor(runif(1, 0, m))#
    K = (m - 1) - J#
#
    while (J > 0) {#
      if (L <= lower) break#
      if (gammas.post(L, p, Sigma.g, Y, eXB, Z, gammas, C, lambda) <= g.post0) break#
      L = L - w#
      J = J - 1#
    }#
#
    while (K > 0) {#
      if (R >= upper) break#
      if (gammas.post(R, p, Sigma.g, Y, eXB, Z, gammas, C, lambda) <= g.post0) break#
      R = R + w#
      K = K - 1#
    }#
  }#
#
  if (L < lower) {#
    L = lower#
  }#
  if (R > upper) {#
    R = upper#
  }#
#
  repeat#
  {#
    g1 = runif(1, L, R)#
    g.post1 = gammas.post(g1, p, Sigma.g, Y, eXB, Z, gammas, C, lambda)#
#
    if (g.post1 >= g.post0) break#
    if (g1 > g0) {#
      R = g1#
    } else {#
      L = g1#
    }#
  }#
  return(g1)#
}#
#
#' @title lambda.slice.sampling#
#' @description univariate slice sampling for lambda#
#'#
#' @param Y response variable#
#' @param eXB exponentiated vector of covariates times betas#
#' @param alpha probability of true censoring#
#' @param C censoring indicator#
#' @param lambda current value of lambda#
#' @param w size of the slice in the slice sampling#
#' @param m limit on steps in the slice sampling#
#' @param lower lower bound on support of the distribution#
#' @param upper upper bound on support of the distribution#
#'#
#' @return One sample update using slice sampling#
#'#
#' @export#
lambda.slice.sampling = function(Y, eXB, alpha, C, lambda, w, m, lower = 0 + 10^(-10), upper = +Inf) {#
  l0 = lambda#
  l.post0 = lambda.post(Y, eXB, alpha, C, l0)#
#
  u = runif(1, 0, w)#
  L = l0 - u#
  R = l0 + (w - u)#
  if (is.infinite(m)) {#
    repeat#
    { if (L <= lower) break#
      if (lambda.post(Y, eXB, alpha, C, L) <= l.post0) break#
      L = L - w#
    }#
    repeat#
    {#
      if (R >= upper) break#
      if (lambda.post(Y, eXB, alpha, C, R) <= l.post0) break#
      R = R + w#
    }#
  } else if (m > 1) {#
    J = floor(runif(1, 0, m))#
    K = (m - 1) - J#
#
    while (J > 0) {#
      if (L <= lower) break#
      if (lambda.post(Y, eXB, alpha, C, L) <= l.post0) break#
      L = L - w#
      J = J - 1#
    }#
#
    while (K > 0) {#
      if (R >= upper) break#
      if (try(lambda.post(Y, eXB, alpha, C, R)) <= l.post0) break#
      R = R + w#
      K = K - 1#
    }#
  }#
#
  if (L < lower) {#
    L = lower#
  }#
  if (R > upper) {#
    R = upper#
  }#
#
  repeat#
  {#
    l1 = runif(1, L, R)#
    l.post1 = lambda.post(Y, eXB, alpha, C, l1)#
#
    if (l.post1 >= l.post0) break#
    if (l1 > l0) {#
      R = l1#
    } else {#
      L = l1#
    }#
  }#
  return(l1)#
}#
#' @title betas.post#
#' @description log-posterior distribution of betas with pth element fixed as betas.p#
#'#
#' @param betas.p current value of the pth element of betas#
#' @param p pth element#
#' @param Sigma.b variance estimate of betas#
#' @param Y response variable#
#' @param X covariates for betas#
#' @param betas current value of betas#
#' @param alpha probability of true censoring#
#' @param C censoring indicator#
#' @param lambda current value of lambda#
#'#
#' @return log- posterior density of betas#
#'#
#' @export#
betas.post = function(betas.p, p, Sigma.b, Y, X, betas, alpha, C, lambda) {#
  betas[p] = betas.p#
  lprior = dmvnorm(betas, rep(0, length(betas)), Sigma.b, log = TRUE)#
  lpost = llikWeibull_betas(Y, X, betas, alpha, C, lambda) + lprior#
  return(lpost)#
}#
#
#' @title gammas.post#
#' @description log-posterior distribution of gammas with pth element fixed as gammas.p#
#'#
#' @param gammas.p current value of the pth element of gammas#
#' @param p pth element#
#' @param Sigma.g variance estimate of gammas#
#' @param Y response variable#
#' @param eXB exponentiated vector of covariates times betas#
#' @param Z covariates for gammas#
#' @param gammas current value of gammas#
#' @param C censoring indicator#
#' @param lambda current value of lambda#
#'#
#' @return log- posterior density of betas#
#'#
#' @export#
gammas.post = function(gammas.p, p, Sigma.g, Y, eXB, Z, gammas, C, lambda) {#
  gammas[p] = gammas.p#
  lprior = dmvnorm(gammas, rep(0, length(gammas)), Sigma.g, log = TRUE)#
  lpost = llikWeibull_gammas(Y, eXB, Z, gammas, C, lambda) + lprior#
  return(lpost)#
}#
#
#' @title lambda.post#
#' @description log-posterior distribution of lambda#
#'#
#' @param Y response variable#
#' @param eXB exponentiated vector of covariates times betas#
#' @param alpha probability of true censoring#
#' @param C censoring indicator#
#' @param lambda current value of lambda#
#' @param a shape parameter of gammas prior#
#' @param b scale parameter of gammas prior#
#'#
#' @return log- posterior density of betas#
#'#
#' @export#
lambda.post = function(Y, eXB, alpha, C, lambda, a = 1, b = 1) {#
  lprior = dgamma(lambda, a, b, log = TRUE)#
  lpost = llikWeibull_lambda(Y, eXB, alpha, C, lambda) + lprior#
  return(lpost)#
}#
#
#' @title mcmcOF#
#' @description Markov Chain Monte Carlo (MCMC) to run Bayesian parametric OF model#
#'#
#' @param Y response variable#
#' @param C censoring indicator#
#' @param X covariates for betas#
#' @param Z covariates for gammas#
#' @param N number of MCMC iterations#
#' @param burn burn-in to be discarded#
#' @param thin thinning to prevent from autocorrelation#
#' @param w size of the slice in the slice sampling for (betas, gammas, lambda)#
#' @param m limit on steps in the slice sampling#
#' @param form type of parametric model (Exponential or Weibull)#
#'#
#' @return chain of the variables of interest#
#'#
#' @export#
mcmcOF<- function(Y, C, X, Z, N, burn, thin, w = c(1, 1, 1), m = 10, form) {#
  p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
#
  # initial values#
  #Sigma.b = 10 * p1 * diag(p1)  # multiply 10 to ensure large enough variance in the early stages#
  #Sigma.g = 10 * p2 * diag(p2)  # multiply 10 to ensure large enough variance in the early stages#
  betas = rep(0, p1)#
  gammas = rep(0, p2)#
  lambda = 1#
  alpha = 1 / (1 + exp(-Z %*% gammas))#
#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  gammas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p2)#
  lambda.samp = rep(NA, (N - burn) / thin)#
  for (iter in 1:N) {#
    if (iter %% 1000 == 0) print(iter)#
    Sigma.b = riwish(1 + p1, betas %*% t(betas) + p1 * diag(p1))#
    Sigma.g = riwish(1 + p2, gammas %*% t(gammas) + p2 * diag(p2))#
    betas = betas.slice.sampling(Sigma.b, Y, X, betas, alpha, C, lambda, w[1], m)#
    eXB = exp(X %*% betas)#
    gammas = gammas.slice.sampling(Sigma.g, Y, eXB, Z, gammas, C, lambda, w[2], m)#
    alpha = 1 / (1 + exp(-Z %*% gammas))#
    if (form %in% "Weibull") {#
    lambda = lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)#
     } #
    if (iter > burn & (iter - burn) %% thin == 0) {#
      betas.samp[(iter - burn) / thin, ] = betas#
      gammas.samp[(iter - burn) / thin, ] = gammas#
      lambda.samp[(iter - burn) / thin] = lambda#
    }#
  }#
  return(list(betas = betas.samp, gammas = gammas.samp, lambda = lambda.samp))#
}
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")
library(Rcpp)
library(RcppArmadillo)
sourceCpp('~/Desktop/BayesOFsurv/pkg/src/sampler.cpp')
sourceCpp('~/Desktop/BayesOFsurv/pkg/src/sampler.cpp')
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(300)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-2#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))
= 1
i = 1
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(300)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-2#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))
i
i = 1
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)
i = 2
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")
.Last.value
.Last.Value
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
#
  # initial values#
  #Sigma.b = 10 * p1 * diag(p1)  # multiply 10 to ensure large enough variance in the early stages#
  #Sigma.g = 10 * p2 * diag(p2)  # multiply 10 to ensure large enough variance in the early stages#
  betas = rep(0, p1)#
  gammas = rep(0, p2)#
  lambda = 1#
  alpha = 1 / (1 + exp(-Z %*% gammas))#
#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  gammas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p2)#
  lambda.samp = rep(NA, (N - burn) / thin)#
  try(for (iter in 1:N) {#
    if (iter %% 1000 == 0) print(iter)#
    Sigma.b = riwish(1 + p1, betas %*% t(betas) + p1 * diag(p1))#
    Sigma.g = riwish(1 + p2, gammas %*% t(gammas) + p2 * diag(p2))#
    betas = betas.slice.sampling(Sigma.b, Y, X, betas, alpha, C, lambda, w[1], m)#
    eXB = exp(X %*% betas)#
    gammas = gammas.slice.sampling(Sigma.g, Y, eXB, Z, gammas, C, lambda, w[2], m)#
    alpha = 1 / (1 + exp(-Z %*% gammas))#
    if (form %in% "Weibull") {#
    lambda = lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)#
     } #
    if (iter > burn & (iter - burn) %% thin == 0) {#
      betas.samp[(iter - burn) / thin, ] = betas#
      gammas.samp[(iter - burn) / thin, ] = gammas#
      lambda.samp[(iter - burn) / thin] = lambda#
    }#
  })
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
#
  # initial values#
  #Sigma.b = 10 * p1 * diag(p1)  # multiply 10 to ensure large enough variance in the early stages#
  #Sigma.g = 10 * p2 * diag(p2)  # multiply 10 to ensure large enough variance in the early stages#
  betas = rep(0, p1)#
  gammas = rep(0, p2)#
  lambda = 1#
  alpha = 1 / (1 + exp(-Z %*% gammas))#
#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  gammas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p2)#
  lambda.samp = rep(NA, (N - burn) / thin)#
  for (iter in 1:N) {print(iter)#
    if (iter %% 1000 == 0) print(iter)#
    Sigma.b = riwish(1 + p1, betas %*% t(betas) + p1 * diag(p1))#
    Sigma.g = riwish(1 + p2, gammas %*% t(gammas) + p2 * diag(p2))#
    betas = betas.slice.sampling(Sigma.b, Y, X, betas, alpha, C, lambda, w[1], m)#
    eXB = exp(X %*% betas)#
    gammas = gammas.slice.sampling(Sigma.g, Y, eXB, Z, gammas, C, lambda, w[2], m)#
    alpha = 1 / (1 + exp(-Z %*% gammas))#
    if (form %in% "Weibull") {#
    lambda = lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)#
     } #
    if (iter > burn & (iter - burn) %% thin == 0) {#
      betas.samp[(iter - burn) / thin, ] = betas#
      gammas.samp[(iter - burn) / thin, ] = gammas#
      lambda.samp[(iter - burn) / thin] = lambda#
    }#
  }
N = 3000
burn = 1000
thin = 20
w = c(1,1,1)
m = 10
form = "Weibull"
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
#
  # initial values#
  #Sigma.b = 10 * p1 * diag(p1)  # multiply 10 to ensure large enough variance in the early stages#
  #Sigma.g = 10 * p2 * diag(p2)  # multiply 10 to ensure large enough variance in the early stages#
  betas = rep(0, p1)#
  gammas = rep(0, p2)#
  lambda = 1#
  alpha = 1 / (1 + exp(-Z %*% gammas))#
#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  gammas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p2)#
  lambda.samp = rep(NA, (N - burn) / thin)#
  for (iter in 1:N) {print(iter)#
    if (iter %% 1000 == 0) print(iter)#
    Sigma.b = riwish(1 + p1, betas %*% t(betas) + p1 * diag(p1))#
    Sigma.g = riwish(1 + p2, gammas %*% t(gammas) + p2 * diag(p2))#
    betas = betas.slice.sampling(Sigma.b, Y, X, betas, alpha, C, lambda, w[1], m)#
    eXB = exp(X %*% betas)#
    gammas = gammas.slice.sampling(Sigma.g, Y, eXB, Z, gammas, C, lambda, w[2], m)#
    alpha = 1 / (1 + exp(-Z %*% gammas))#
    if (form %in% "Weibull") {#
    lambda = lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)#
     } #
    if (iter > burn & (iter - burn) %% thin == 0) {#
      betas.samp[(iter - burn) / thin, ] = betas#
      gammas.samp[(iter - burn) / thin, ] = gammas#
      lambda.samp[(iter - burn) / thin] = lambda#
    }#
  }
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(300)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-2#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))
i = 1
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)
i = 2
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)
#set seed#
set.seed(300)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-2#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))
i = 1
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)
i = 2
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")
betas = c(5.60188629,  2.33398439)
gammas = c(0.35742156,  0.04595671, -2.91431118 )
lambda = 0.23649873
gammas.slice.sampling(Sigma.g, Y, eXB, Z, gammas, C, lambda, w[2], m)
Sigma.b = riwish(1 + p1, betas %*% t(betas) + p1 * diag(p1))#
    Sigma.g = riwish(1 + p2, gammas %*% t(gammas) + p2 * diag(p2))
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
#
  # initial values#
  #Sigma.b = 10 * p1 * diag(p1)  # multiply 10 to ensure large enough variance in the early stages#
  #Sigma.g = 10 * p2 * diag(p2)  # multiply 10 to ensure large enough variance in the early stages#
  betas = rep(0, p1)#
  gammas = rep(0, p2)
betas = c(5.60188629,  2.33398439)
gammas = c(0.35742156,  0.04595671, -2.91431118 )
Sigma.b = riwish(1 + p1, betas %*% t(betas) + p1 * diag(p1))
Sigma.g = riwish(1 + p2, gammas %*% t(gammas) + p2 * diag(p2))
eXB = exp(X %*% betas)
alpha = 1 / (1 + exp(-Z %*% gammas))
lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)
w = c(1,1,1)
m = 10
lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)
lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)
lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)
lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)
lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)
lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)
lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)
lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)
lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)
lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)
lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)
lambda.slice.sampling(Y, eXB, alpha, C, lambda, w[3], m)
weib.est
l0 = lambda#
  l.post0 = lambda.post(Y, eXB, alpha, C, l0)
l.post0
u = runif(1, 0, w)#
  L = l0 - u#
  R = l0 + (w - u)
L
R
w = 1
L
u = runif(1, 0, w)#
  L = l0 - u#
  R = l0 + (w - u)
L
R
if (m > 1) {#
    J = floor(runif(1, 0, m))#
    K = (m - 1) - J#
#
    while (J > 0) {#
      if (L <= lower) break#
      if (lambda.post(Y, eXB, alpha, C, L) <= l.post0) break#
      L = L - w#
      J = J - 1#
    }#
#
    while (K > 0) {#
      if (R >= upper) break#
      if (lambda.post(Y, eXB, alpha, C, R) <= l.post0) break#
      R = R + w#
      K = K - 1#
    }#
  }
lower =  0 + 10^(-10),
lower =  0 + 10^(-10)
upper = Inf
if (m > 1) {#
    J = floor(runif(1, 0, m))#
    K = (m - 1) - J#
#
    while (J > 0) {#
      if (L <= lower) break#
      if (lambda.post(Y, eXB, alpha, C, L) <= l.post0) break#
      L = L - w#
      J = J - 1#
    }#
#
    while (K > 0) {#
      if (R >= upper) break#
      if (lambda.post(Y, eXB, alpha, C, R) <= l.post0) break#
      R = R + w#
      K = K - 1#
    }#
  }
L
R
if (L < lower) {#
    L = lower#
  }#
  if (R > upper) {#
    R = upper#
  }#
#
  repeat#
  {#
    l1 = runif(1, L, R)#
    l.post1 = lambda.post(Y, eXB, alpha, C, l1)#
#
    if (l.post1 >= l.post0) break#
    if (l1 > l0) {#
      R = l1#
    } else {#
      L = l1#
    }#
  }
lambda.post(Y, eXB, alpha, C, R)
lambda.post(Y, eXB, alpha, C, 100)
lambda.post(Y, eXB, alpha, C, 10)
lambda.post(Y, eXB, alpha, C, 2)
lambda.post(Y, eXB, alpha, C, 1)
lambda.post(Y, eXB, alpha, C, 1.5)
lambda.post(Y, eXB, alpha, C, 1.4)
lambda.post(Y, eXB, alpha, C, 1.3)
lambda.post(Y, eXB, alpha, C, 1.2)
lambda.post(Y, eXB, alpha, C, 1.25)
lambda.post(Y, eXB, alpha, C, 1.28)
a
a = 1
b = 1
dgamma(lambda, a, b, log = TRUE)
dgamma(1.5, a, b, log = TRUE)
dgamma(2, a, b, log = TRUE)
llikWeibull_lambda(Y, eXB, alpha, C, lambda)
library(Rcpp)
library(RcppArmadillo)
sourceCpp('~/Desktop/BayesOFsurv/pkg/src/sampler.cpp')
llikWeibull_lambda(Y, eXB, alpha, C, lambda)
llikWeibull_lambda(Y, eXB, alpha, C, 1.5)
llikWeibull_lambda(Y, eXB, alpha, C, 13)
llikWeibull_lambda(Y, eXB, alpha, C, 100)
llikWeibull_lambda(Y, eXB, alpha, C,-1)
llikWeibull_lambda(Y, eXB, alpha, C,0.001)
llikWeibull_lambda(Y, eXB, alpha, C, 1.12)
sourceCpp('~/Desktop/BayesOFsurv/pkg/src/sampler.cpp')
sourceCpp('~/Desktop/BayesOFsurv/pkg/src/sampler.cpp')
llikWeibull_lambda(Y, eXB, alpha, C, 1.5)
Y[98]
X[98]
eXB[98]
eXB[97]
C[98]
alpha[98]
log(alpha[98])
(eXB[98]*Y[98])^1.5
C * log(alpha*exp(-(eXB*Y)^(1.5))+(1-alpha)*(1.5)*eXB*-(eXB*Y)^(1.5-1)*exp(-(eXB*Y)^(1.5)))
exp(-(eXB * Y)^(1.5))
alpha * exp(-(eXB * Y)^(1.5))
C * log(alpha*exp(-(eXB*Y)^(1.5))+(1-alpha)*(1.5)*eXB*(eXB*Y)^(1.5-1)*exp(-(eXB*Y)^(1.5)))
log(alpha*exp(-(eXB*Y)^(1.5))+(1-alpha)*(1.5)*eXB*(eXB*Y)^(1.5-1)*exp(-(eXB*Y)^(1.5)))
-Inf * 0
alpha*exp(-(eXB*Y)^(1.5))+(1-alpha)*(1.5)*eXB*(eXB*Y)^(1.5-1)*exp(-(eXB*Y)^(1.5))
alpha*exp(-(eXB*Y)^(1.5))
(1-alpha)*(1.5)*eXB*(eXB*Y)^(1.5-1)*exp(-(eXB*Y)^(1.5))
eXB
(1-alpha)*(1.5)*eXB*(eXB*Y)^(1.5-1)*exp(-(eXB*Y)^(1.5))
eXB*(eXB*Y)^(1.5-1)*exp(-(eXB*Y)^(1.5))
exp(-(eXB*Y)^(1.5))
exp(-(eXB*Y)^(1.5))
-(eXB*Y)^(1.5)
exp(-(eXB*Y)^(1.5))
sourceCpp('~/Desktop/BayesOFsurv/pkg/src/sampler.cpp')
sourceCpp('~/Desktop/BayesOFsurv/pkg/src/sampler.cpp')
llikWeibull_lambda(Y, eXB, alpha, C, 1.5)
llikWeibull_lambda(Y, eXB, alpha, C, 100)
llikWeibull_lambda(Y, eXB, alpha, C,-1)
llikWeibull_lambda(Y, eXB, alpha, C,0.0001)
llikWeibull_lambda(Y, eXB, alpha, C,1.12)
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(3)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-1000#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
#create a dependent variable, begin the simmulations#
for(i in 1:nsims){#
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
#combine matrices and label variables#
main.data<-cbind(tru.est, cox.est, exp.est, weib.est, cox.rmse, exp.rmse, weib.rmse, cox.cp, exp.cp, weib.cp)#
colnames(main.data)<-c("true.x0","true.x1","true.z0","true.z1","true.z2","true.p","cen.lat","cen.obs",#
	"cox.x1","cox.x1.se",#
	"exp.x0","exp.x0.se","exp.x1","exp.x1.se",#
	"zexp.z0","zexp.z0.se","zexp.z1","zexp.z1.se","zexp.z2","zexp.z2.se","zexp.x0","zexp.x0.se","zexp.x1","zexp.x1.se",#
	"bzexp.x0","zexp.x0.se","bzexp.x1","bzexp.x1.se","bzexp.z0","bzexp.z0.se","bzexp.z1","bzexp.z1.se","bzexp.z2","bzexp.z2.se",#
	"wei.x0","wei.x0.se","wei.x1","wei.x1.se","wei.p","wei.p.se",#
	"zwei.z0","zwei.z0.se","zwei.z1","zwei.z1.se","zwei.z2","zwei.z2.se","zwei.x0","zwei.x0.se","zwei.x1","zwei.x1.se","zwei.p","zwei.p.se",#
	"bzwei.x0","bzwei.x0.se","bzwei.x1","bzwei.x1.se","bzwei.z0","bzwei.z0.se","bzwei.z1","bzwei.z1.se","bzwei.z2","bzwei.z2.se","bzwei.p","bzwei.p.se",#
	"cox.x1.rmse",#
	"exp.x0.rmse","exp.x1.rmse","zexp.z0.rmse","zexp.z1.rmse","zexp.z2.rmse","zexp.x0.rmse","zexp.x1.rmse","bzexp.x0.rmse","bzexp.x1.rmse","bzexp.z0.rmse","bzexp.z1.rmse","bzexp.z2.rmse",#
	"wei.x0.rmse","wei.x1.rmse","wei.p.rmse","zwei.z0.rmse","zwei.z1.rmse","zwei.z2.rmse",#
	"zwei.x0.rmse","zwei.x1.rmse","zwei.p.rmse", "bzwei.x0.rmse","bzwei.x1.rmse","bzwei.z0.rmse","bzwei.z1.rmse","bzwei.z2.rmse","bzwei.p.rmse",#
	"cox.x1.cp","exp.x0.cp","exp.x1.cp","zexp.z0.cp","zexp.z1.cp","zexp.z2.cp","zexp.x0.cp","zexp.x1.cp","bzexp.x0.cp","bzexp.x1.cp","bzexp.z0.cp","bzexp.z1.cp","bzexp.z2.cp",#
	"wei.x0.cp","wei.x1.cp","wei.p.cp",#
	"zwei.z0.cp","zwei.z1.cp","zwei.z2.cp","zwei.x0.cp","zwei.x1.cp","zwei.p.cp", "bzwei.x0.cp","bzwei.x1.cp","bzwei.z0.cp","bzwei.z1.cp","bzwei.z2.cp","bzwei.p.cp")#
#save dataset#
main.data2<-as.data.frame(main.data)#
write.dta(main.data2,"main.data2.dta", )
alpha
####
###1. Store True values for X0, X1, Z0, Z1, Z2, P#
###2. Store proportion censored pre & post#
###3. Simmulate n of 1000, do this 1000 times#
###4. Estimate cox, weibull, store all relevant coefficient estimates (exponentiate p's where applicable)#
###5. For each value in 4, calculate CPs and RMSEs, store.#
###6. Estimate zombie exp and zombie weibull-->store all relevant coefficient estimates (exponentiate p's where applicable).#
###7. For each value in 6, calculate CPs and RMSEs, store.#
###8. Estimate Bayesian zombie exp and Bayesian zombie weibull-->store all relevant coefficient estimates (exponentiate p's where applicable).#
###9. For each value in 8, calculate CPs and RMSEs, store.#
###############
####Set Up#####
###############
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(3)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-1000#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
#create a dependent variable, begin the simmulations#
for(i in 1:nsims){#
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
#combine matrices and label variables#
main.data<-cbind(tru.est, cox.est, exp.est, weib.est, cox.rmse, exp.rmse, weib.rmse, cox.cp, exp.cp, weib.cp)#
colnames(main.data)<-c("true.x0","true.x1","true.z0","true.z1","true.z2","true.p","cen.lat","cen.obs",#
	"cox.x1","cox.x1.se",#
	"exp.x0","exp.x0.se","exp.x1","exp.x1.se",#
	"zexp.z0","zexp.z0.se","zexp.z1","zexp.z1.se","zexp.z2","zexp.z2.se","zexp.x0","zexp.x0.se","zexp.x1","zexp.x1.se",#
	"bzexp.x0","zexp.x0.se","bzexp.x1","bzexp.x1.se","bzexp.z0","bzexp.z0.se","bzexp.z1","bzexp.z1.se","bzexp.z2","bzexp.z2.se",#
	"wei.x0","wei.x0.se","wei.x1","wei.x1.se","wei.p","wei.p.se",#
	"zwei.z0","zwei.z0.se","zwei.z1","zwei.z1.se","zwei.z2","zwei.z2.se","zwei.x0","zwei.x0.se","zwei.x1","zwei.x1.se","zwei.p","zwei.p.se",#
	"bzwei.x0","bzwei.x0.se","bzwei.x1","bzwei.x1.se","bzwei.z0","bzwei.z0.se","bzwei.z1","bzwei.z1.se","bzwei.z2","bzwei.z2.se","bzwei.p","bzwei.p.se",#
	"cox.x1.rmse",#
	"exp.x0.rmse","exp.x1.rmse","zexp.z0.rmse","zexp.z1.rmse","zexp.z2.rmse","zexp.x0.rmse","zexp.x1.rmse","bzexp.x0.rmse","bzexp.x1.rmse","bzexp.z0.rmse","bzexp.z1.rmse","bzexp.z2.rmse",#
	"wei.x0.rmse","wei.x1.rmse","wei.p.rmse","zwei.z0.rmse","zwei.z1.rmse","zwei.z2.rmse",#
	"zwei.x0.rmse","zwei.x1.rmse","zwei.p.rmse", "bzwei.x0.rmse","bzwei.x1.rmse","bzwei.z0.rmse","bzwei.z1.rmse","bzwei.z2.rmse","bzwei.p.rmse",#
	"cox.x1.cp","exp.x0.cp","exp.x1.cp","zexp.z0.cp","zexp.z1.cp","zexp.z2.cp","zexp.x0.cp","zexp.x1.cp","bzexp.x0.cp","bzexp.x1.cp","bzexp.z0.cp","bzexp.z1.cp","bzexp.z2.cp",#
	"wei.x0.cp","wei.x1.cp","wei.p.cp",#
	"zwei.z0.cp","zwei.z1.cp","zwei.z2.cp","zwei.x0.cp","zwei.x1.cp","zwei.p.cp", "bzwei.x0.cp","bzwei.x1.cp","bzwei.z0.cp","bzwei.z1.cp","bzwei.z2.cp","bzwei.p.cp")#
#save dataset#
main.data2<-as.data.frame(main.data)#
write.dta(main.data2,"main.data2.dta", )
#clear memory#
rm( list=ls() )#
#load necessary libraries 						                                 #
library(foreign)#
library(Zelig)#
library(car)#
library(MASS)#
library(VGAM)#
library(plotrix)#
library(pscl)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)#
library(mvtnorm)#
library(MCMCpack)#
library(devtools)#
install_github('bomin8319/BayesOFsurv/pkg')#
library(BayesOFsurv)#
#set working directory#
setwd("/Users/bomin8319/Desktop/BayesOFsurv/coding material/Monte Carlos/Mixture DGP/")#
###########################################################################
###########################################################################
############################Monte Carlo####################################
###########################################################################
#set seed#
set.seed(300)   #
#set the number of observations#
n<-100#
#set the number of simulations, and create matrices to store the results#
nsims<-2#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=24)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=30)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=15)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=12)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=15)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
#create a dependent variable, begin the simmulations#
for(i in 1:nsims){#
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<-2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
print(mean(phi))#
yzero<-matrix(1,n,1)#
error<--1*rlogis(n)#
flag<-error<qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==1#
di[flag]<-ifelse(di[flag]==0,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)#
######################################################################################
###################################COX Model##########################################
######################################################################################
#store estimate and se#
cox.est[i,1]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[1]#
cox.est[i,2]<-summary(coxph(Surv(ycen, di)~x,coxph.control(iter.max = 10000)))$coef[3]#
#store rmse#
cox.rmse[i,1]<-sqrt((tru.est[i,2]-cox.est[i,1])^2)#
#calculate upper and lower 95% CI's#
b1.lower<-cox.est[i,1]-(1.959964*cox.est[i,2])#
b1.upper<-cox.est[i,1]+(1.959964*cox.est[i,2])#
#store coverage parameters#
cox.cp[i,1]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
##############################################################################
########################Simple Exponential Model##############################
##############################################################################
Exponential<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)]#
	XB<-X%*%beta#
	llik<-C*(XB-exp(XB)*Y)+(1-C)*(-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Exponential<-try(optim(f=Exponential,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Exponential)=="list"){#
	ifelse(is.positive.definite(output.Exponential$hessian)==TRUE,vcv<-solve(output.Exponential$hessian),vcv<-matrix(data=NA,nrow=2,ncol=2))#
#store betas and ses#
exp.est[i,1]<-output.Exponential$par[1]#
exp.est[i,2]<-sqrt(vcv[1,1])#
exp.est[i,3]<-output.Exponential$par[2]#
exp.est[i,4]<-sqrt(vcv[2,2])#
#store rmse#
exp.rmse[i,1]<-sqrt((tru.est[i,1]-exp.est[i,1])^2)#
exp.rmse[i,2]<-sqrt((tru.est[i,2]-exp.est[i,3])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-exp.est[i,1]-(1.959964*exp.est[i,2])#
b0.upper<-exp.est[i,1]+(1.959964*exp.est[i,2])#
b1.lower<-exp.est[i,3]-(1.959964*exp.est[i,4])#
b1.upper<-exp.est[i,3]+(1.959964*exp.est[i,4])#
#store coverage parameters#
exp.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
#################################################################################
#########################Simple Weibull Model ###################################
#################################################################################
#Note this estiamtes the model via hazard rates, a la Stata#
test<-survreg(Surv(ycen, di)~x, dist="weibull")#
summary(test)#
Weibull<- function(est,Y,C,X,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	beta<-est[1:length(est)-1]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	llik<-C*(log(exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*log(exp(-(exp(XB+1/p)*Y)^p))#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(exp.est[i,1],exp.est[i,3],.01)#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
#optimize#
output.Weibull<-try(optim(f=Weibull,  p=est, X=X,Y=Y,C=C, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.Weibull)=="list"){#
	ifelse(is.positive.definite(output.Weibull$hessian)==TRUE,vcv<-solve(output.Weibull$hessian),vcv<-matrix(data=NA,nrow=3,ncol=3))#
#store betas and ses#
weib.est[i,1]<-output.Weibull$par[1]+1/exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,1],output.Weibull$par[3])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,3]#
varcov[2,1]<-vcv[3,1]#
varcov[2,2]<-vcv[3,3]#
weib.est[i,2]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,3]<-output.Weibull$par[2]#
weib.est[i,4]<-sqrt(vcv[2,2])#
weib.est[i,5]<-exp(output.Weibull$par[3])#
coeff<-c(weib.est[i,5])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[3,3]#
weib.est[i,6]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,1]<-sqrt((tru.est[i,1]-weib.est[i,1])^2)#
weib.rmse[i,2]<-sqrt((tru.est[i,2]-weib.est[i,3])^2)#
weib.rmse[i,3]<-sqrt((tru.est[i,6]-weib.est[i,5])^2)#
#calculate upper and lower 95% CI's#
b0.lower<-weib.est[i,1]-(1.959964*weib.est[i,2])#
b0.upper<-weib.est[i,1]+(1.959964*weib.est[i,2])#
b1.lower<-weib.est[i,3]-(1.959964*weib.est[i,4])#
b1.upper<-weib.est[i,3]+(1.959964*weib.est[i,4])#
p.lower<-weib.est[i,5]-(1.959964*weib.est[i,6])#
p.upper<-weib.est[i,5]+(1.959964*weib.est[i,6])#
#store coverage parameters#
weib.cp[i,1]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,2]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,3]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
###logit estimates####
dataset<-as.data.frame(data)#
logitcoef1<-glm(di~ z+x, data = dataset, family = "binomial")$coef[1]#
logitcoef2<-glm(di~ z+x, data = dataset, family = "binomial")$coef[2]#
logitcoef3<-glm(di~ z+x, data = dataset, family = "binomial")$coef[3]#
################################################################################
##########################Zombie Exponential Model##############################
################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZExponential<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):length(est)]#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-ZG))#
	llik<-C*(log(phi*exp(-exp(XB)*Y)+(1-phi)*exp(XB)*exp(-exp(XB)*Y)))+(1-C)*(log(phi)+-exp(XB)*Y)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,exp.est[i,1],exp.est[i,3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZExponential<-try(optim(f=ZExponential,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZExponential)=="list"){#
	ifelse(is.positive.definite(output.ZExponential$hessian)==TRUE,vcv<-solve(output.ZExponential$hessian),vcv<-matrix(data=NA,nrow=5,ncol=5))#
#store betas and ses#
exp.est[i,5]<-output.ZExponential$par[1]#
exp.est[i,6]<-sqrt(vcv[1,1])#
exp.est[i,7]<-output.ZExponential$par[2]#
exp.est[i,8]<-sqrt(vcv[2,2])#
exp.est[i,9]<-output.ZExponential$par[3]#
exp.est[i,10]<-sqrt(vcv[3,3])#
exp.est[i,11]<-output.ZExponential$par[4]#
exp.est[i,12]<-sqrt(vcv[4,4])#
exp.est[i,13]<-output.ZExponential$par[5]#
exp.est[i,14]<-sqrt(vcv[5,5])#
#store rmse#
exp.rmse[i,3]<-sqrt((tru.est[i,3]-exp.est[i,5])^2)#
exp.rmse[i,4]<-sqrt((tru.est[i,4]-exp.est[i,7])^2)#
exp.rmse[i,5]<-sqrt((tru.est[i,5]-exp.est[i,9])^2)#
exp.rmse[i,6]<-sqrt((tru.est[i,1]-exp.est[i,11])^2)#
exp.rmse[i,7]<-sqrt((tru.est[i,2]-exp.est[i,13])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-exp.est[i,5]-(1.959964*exp.est[i,6])#
g0.upper<-exp.est[i,5]+(1.959964*exp.est[i,6])#
g1.lower<-exp.est[i,7]-(1.959964*exp.est[i,8])#
g1.upper<-exp.est[i,7]+(1.959964*exp.est[i,8])#
g2.lower<-exp.est[i,9]-(1.959964*exp.est[i,10])#
g2.upper<-exp.est[i,9]+(1.959964*exp.est[i,10])#
b0.lower<-exp.est[i,11]-(1.959964*exp.est[i,12])#
b0.upper<-exp.est[i,11]+(1.959964*exp.est[i,12])#
b1.lower<-exp.est[i,13]-(1.959964*exp.est[i,14])#
b1.upper<-exp.est[i,13]+(1.959964*exp.est[i,14])#
#store coverage parameters#
exp.cp[i,3]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,4]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,5]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,6]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,7]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
}#
######################################################################################
##########################Zombie Weibull Model #######################################
######################################################################################
#This program estimates the Exponential loglikelihood function returning hazard rate form coefficients#
ZWeibull<- function(est,Y,C,X,Z,data) {					      #
	n=nrow(data)							      					  #
	llik <- matrix(0, nrow=n, ncol = 1)#
	gamma<-est[1:ncol(Z)]#
	beta<-est[(ncol(Z)+1):(length(est)-1)]#
	p<-est[length(est)]#
	p<-exp(p)#
	XB<-X%*%beta#
	ZG<-Z%*%gamma#
	phi<-1/(1+exp(-(ZG+1/p)))#
	llik<-C*(log(phi*exp(-(exp(XB+1/p)*Y)^p)+(1-phi)*exp(XB+1/p)*p*((exp(XB+1/p)*Y)^(p-1))*exp(-(exp(XB+1/p)*Y)^p)))+(1-C)*(log(phi)+-(exp(XB+1/p)*Y)^p)#
	llik<--1*sum(llik)#
	return(llik)#
	}#
#set starting parameters#
est<-rbind(.01,.01,.01,output.Weibull$par[1],output.Weibull$par[2],output.Weibull$par[3])#
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
#optimize#
output.ZWeibull<-try(optim(f=ZWeibull,  p=est, X=X,Y=Y,C=C,Z=Z, method="BFGS", control=list(maxit=10000),  data=data, hessian=TRUE), TRUE)#
if(class(output.ZWeibull)=="list"){#
	ifelse(is.positive.definite(output.ZWeibull$hessian)==TRUE,vcv<-solve(output.ZWeibull$hessian),vcv<-matrix(data=NA,nrow=6,ncol=6))#
#store betas and ses#
weib.est[i,7]<-output.ZWeibull$par[1]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,7],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[1,1]#
varcov[1,2]<-vcv[1,6]#
varcov[2,1]<-vcv[6,1]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,8]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,9]<-output.ZWeibull$par[2]#
weib.est[i,10]<-sqrt(vcv[2,2])#
weib.est[i,11]<-output.ZWeibull$par[3]#
weib.est[i,12]<-sqrt(vcv[3,3])#
weib.est[i,13]<-output.ZWeibull$par[4]+1/exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,13],output.ZWeibull$par[6])#
varcov<-matrix(NA,2,2)#
varcov[1,1]<-vcv[4,4]#
varcov[1,2]<-vcv[4,6]#
varcov[2,1]<-vcv[6,4]#
varcov[2,2]<-vcv[6,6]#
weib.est[i,14]<-deltamethod(~(x1+1/exp(x2)), coeff, varcov, ses=TRUE)#
weib.est[i,15]<-output.ZWeibull$par[5]#
weib.est[i,16]<-sqrt(vcv[5,5])#
weib.est[i,17]<-exp(output.ZWeibull$par[6])#
coeff<-c(weib.est[i,17])#
varcov<-matrix(NA,1,1)#
varcov[1,1]<-vcv[6,6]#
weib.est[i,18]<-deltamethod(~(exp(x1)), coeff, varcov, ses=TRUE)#
#store rmse#
weib.rmse[i,4]<-sqrt((tru.est[i,3]-weib.est[i,7])^2)#
weib.rmse[i,5]<-sqrt((tru.est[i,4]-weib.est[i,9])^2)#
weib.rmse[i,6]<-sqrt((tru.est[i,5]-weib.est[i,11])^2)#
weib.rmse[i,7]<-sqrt((tru.est[i,1]-weib.est[i,13])^2)#
weib.rmse[i,8]<-sqrt((tru.est[i,2]-weib.est[i,15])^2)#
weib.rmse[i,9]<-sqrt((tru.est[i,6]-weib.est[i,17])^2)#
#calculate upper and lower 95% CI's#
g0.lower<-weib.est[i,7]-(1.959964*weib.est[i,8])#
g0.upper<-weib.est[i,7]+(1.959964*weib.est[i,8])#
g1.lower<-weib.est[i,9]-(1.959964*weib.est[i,10])#
g1.upper<-weib.est[i,9]+(1.959964*weib.est[i,10])#
g2.lower<-weib.est[i,11]-(1.959964*weib.est[i,12])#
g2.upper<-weib.est[i,11]+(1.959964*weib.est[i,12])#
b0.lower<-weib.est[i,13]-(1.959964*weib.est[i,14])#
b0.upper<-weib.est[i,13]+(1.959964*weib.est[i,14])#
b1.lower<-weib.est[i,15]-(1.959964*weib.est[i,16])#
b1.upper<-weib.est[i,15]+(1.959964*weib.est[i,16])#
p.lower<-weib.est[i,17]-(1.959964*weib.est[i,18])#
p.upper<-weib.est[i,17]+(1.959964*weib.est[i,18])#
#store coverage parameters#
weib.cp[i,4]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,5]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,6]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,7]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,8]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,9]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
################################################################################
######################Bayesian Zombie Exponential Model#########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZExponential = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Exponential")#
output.BayesZExponential = list(par = c(summary(mcmc(BayesZExponential$beta))[[1]][,1], summary(mcmc(BayesZExponential$gamma))[[1]][,1]), #
								se = c(summary(mcmc(BayesZExponential$beta))[[1]][,2], summary(mcmc(BayesZExponential$gamma))[[1]][,2]),#
								CI = rbind(summary(mcmc(BayesZExponential$beta))[[2]], summary(mcmc(BayesZExponential$gamma))[[2]]))#
exp.est[i,15]<-output.BayesZExponential$par[1]#
exp.est[i,16]<-output.BayesZExponential$se[1]#
exp.est[i,17]<-output.BayesZExponential$par[2]#
exp.est[i,18]<-output.BayesZExponential$se[2]#
exp.est[i,19]<-output.BayesZExponential$par[3]#
exp.est[i,20]<-output.BayesZExponential$se[3]#
exp.est[i,21]<-output.BayesZExponential$par[4]#
exp.est[i,22]<-output.BayesZExponential$se[4]#
exp.est[i,23]<-output.BayesZExponential$par[5]#
exp.est[i,24]<-output.BayesZExponential$se[5]#
#
#store rmse#
exp.rmse[i,8]<-sqrt((tru.est[i,3]-exp.est[i,15])^2)#
exp.rmse[i,9]<-sqrt((tru.est[i,4]-exp.est[i,17])^2)#
exp.rmse[i,10]<-sqrt((tru.est[i,5]-exp.est[i,19])^2)#
exp.rmse[i,11]<-sqrt((tru.est[i,1]-exp.est[i,21])^2)#
exp.rmse[i,12]<-sqrt((tru.est[i,2]-exp.est[i,23])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZExponential$CI[1,1]#
# b0.upper<-output.BayesZExponential$CI[1,5]#
# b1.lower<-output.BayesZExponential$CI[2,1]#
# b1.upper<-output.BayesZExponential$CI[2,5]#
# g0.lower<-output.BayesZExponential$CI[3,1]#
# g0.upper<-output.BayesZExponential$CI[3,5]#
# g1.lower<-output.BayesZExponential$CI[4,1]#
# g1.upper<-output.BayesZExponential$CI[4,5]#
# g2.lower<-output.BayesZExponential$CI[5,1]#
# g2.upper<-output.BayesZExponential$CI[5,5]#
b0.lower<-exp.est[i,15]-(1.959964*exp.est[i,16])#
b0.upper<-exp.est[i,15]+(1.959964*exp.est[i,16])#
b1.lower<-exp.est[i,17]-(1.959964*exp.est[i,18])#
b1.upper<-exp.est[i,17]+(1.959964*exp.est[i,18])#
g0.lower<-exp.est[i,19]-(1.959964*exp.est[i,20])#
g0.upper<-exp.est[i,19]+(1.959964*exp.est[i,20])#
g1.lower<-exp.est[i,21]-(1.959964*exp.est[i,22])#
g1.upper<-exp.est[i,21]+(1.959964*exp.est[i,22])#
g2.lower<-exp.est[i,23]-(1.959964*exp.est[i,24])#
g2.upper<-exp.est[i,23]+(1.959964*exp.est[i,24])#
#store coverage parameters#
exp.cp[i,8]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
exp.cp[i,9]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
exp.cp[i,10]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
exp.cp[i,11]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
exp.cp[i,12]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
#
################################################################################
########################Bayesian Zombie Weibull Model###########################
################################################################################
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)#
BayesZWeibull = mcmcOF(Y, C, X, Z, N = 3000, burn = 1000, thin = 20,  w = c(1, 1, 1), m = 10, form = "Weibull")#
output.BayesZWeibull = list(par = c(summary(mcmc(BayesZWeibull$beta))[[1]][,1], summary(mcmc(BayesZWeibull$gamma))[[1]][,1], #
									summary(mcmc(BayesZWeibull$lambda))[[1]][1]), #
								se = c(summary(mcmc(BayesZWeibull$beta))[[1]][,2], summary(mcmc(BayesZWeibull$gamma))[[1]][,2], #
									   summary(mcmc(BayesZWeibull$lambda))[[1]][2]),#
								CI = rbind(summary(mcmc(BayesZWeibull$beta))[[2]], summary(mcmc(BayesZWeibull$gamma))[[2]], #
										summary(mcmc(BayesZWeibull$lambda))[[2]]))#
#
weib.est[i,19]<-output.BayesZWeibull$par[1]#
weib.est[i,20]<-output.BayesZWeibull$se[1]#
weib.est[i,21]<-output.BayesZWeibull$par[2]#
weib.est[i,22]<-output.BayesZWeibull$se[2]#
weib.est[i,23]<-output.BayesZWeibull$par[3]#
weib.est[i,24]<-output.BayesZWeibull$se[3]#
weib.est[i,25]<-output.BayesZWeibull$par[4]#
weib.est[i,26]<-output.BayesZWeibull$se[4]#
weib.est[i,27]<-output.BayesZWeibull$par[5]#
weib.est[i,28]<-output.BayesZWeibull$se[5]#
weib.est[i,29]<-output.BayesZWeibull$par[6]#
weib.est[i,30]<-output.BayesZWeibull$se[6]#
#
#store rmse#
weib.rmse[i,10]<-sqrt((tru.est[i,3]-weib.est[i,19])^2)#
weib.rmse[i,11]<-sqrt((tru.est[i,4]-weib.est[i,21])^2)#
weib.rmse[i,12]<-sqrt((tru.est[i,5]-weib.est[i,23])^2)#
weib.rmse[i,13]<-sqrt((tru.est[i,1]-weib.est[i,25])^2)#
weib.rmse[i,14]<-sqrt((tru.est[i,2]-weib.est[i,27])^2)#
weib.rmse[i,15]<-sqrt((tru.est[i,6]-weib.est[i,29])^2)#
#
#calculate upper and lower 95% CI's#
# b0.lower<-output.BayesZWeibull$CI[1,1]#
# b0.upper<-output.BayesZWeibull$CI[1,5]#
# b1.lower<-output.BayesZWeibull$CI[2,1]#
# b1.upper<-output.BayesZWeibull$CI[2,5]#
# g0.lower<-output.BayesZWeibull$CI[3,1]#
# g0.upper<-output.BayesZWeibull$CI[3,5]#
# g1.lower<-output.BayesZWeibull$CI[4,1]#
# g1.upper<-output.BayesZWeibull$CI[4,5]#
# g2.lower<-output.BayesZWeibull$CI[5,1]#
# g2.upper<-output.BayesZWeibull$CI[5,5]#
# p.lower<-output.BayesZWeibull$CI[6,1]#
# p.upper<-output.BayesZWeibull$CI[6,2]#
g0.lower<-weib.est[i,19]-(1.959964*weib.est[i,20])#
g0.upper<-weib.est[i,19]+(1.959964*weib.est[i,20])#
g1.lower<-weib.est[i,21]-(1.959964*weib.est[i,22])#
g1.upper<-weib.est[i,21]+(1.959964*weib.est[i,22])#
g2.lower<-weib.est[i,23]-(1.959964*weib.est[i,24])#
g2.upper<-weib.est[i,23]+(1.959964*weib.est[i,24])#
b0.lower<-weib.est[i,25]-(1.959964*weib.est[i,26])#
b0.upper<-weib.est[i,25]+(1.959964*weib.est[i,26])#
b1.lower<-weib.est[i,27]-(1.959964*weib.est[i,28])#
b1.upper<-weib.est[i,27]+(1.959964*weib.est[i,28])#
p.lower<-weib.est[i,29]-(1.959964*weib.est[i,30])#
p.upper<-weib.est[i,29]+(1.959964*weib.est[i,30])#
#store coverage parameters#
weib.cp[i,10]<-ifelse(tru.est[i,3]>g0.lower & tru.est[i,3]<g0.upper, 1,0)#
weib.cp[i,11]<-ifelse(tru.est[i,4]>g1.lower & tru.est[i,4]<g1.upper, 1,0)#
weib.cp[i,12]<-ifelse(tru.est[i,5]>g2.lower & tru.est[i,5]<g2.upper, 1,0)#
weib.cp[i,13]<-ifelse(tru.est[i,1]>b0.lower & tru.est[i,1]<b0.upper, 1,0)#
weib.cp[i,14]<-ifelse(tru.est[i,2]>b1.lower & tru.est[i,2]<b1.upper, 1,0)#
weib.cp[i,15]<-ifelse(tru.est[i,6]>p.lower & tru.est[i,6]<p.upper, 1,0)#
}#
#combine matrices and label variables#
main.data<-cbind(tru.est, cox.est, exp.est, weib.est, cox.rmse, exp.rmse, weib.rmse, cox.cp, exp.cp, weib.cp)#
colnames(main.data)<-c("true.x0","true.x1","true.z0","true.z1","true.z2","true.p","cen.lat","cen.obs",#
	"cox.x1","cox.x1.se",#
	"exp.x0","exp.x0.se","exp.x1","exp.x1.se",#
	"zexp.z0","zexp.z0.se","zexp.z1","zexp.z1.se","zexp.z2","zexp.z2.se","zexp.x0","zexp.x0.se","zexp.x1","zexp.x1.se",#
	"bzexp.x0","zexp.x0.se","bzexp.x1","bzexp.x1.se","bzexp.z0","bzexp.z0.se","bzexp.z1","bzexp.z1.se","bzexp.z2","bzexp.z2.se",#
	"wei.x0","wei.x0.se","wei.x1","wei.x1.se","wei.p","wei.p.se",#
	"zwei.z0","zwei.z0.se","zwei.z1","zwei.z1.se","zwei.z2","zwei.z2.se","zwei.x0","zwei.x0.se","zwei.x1","zwei.x1.se","zwei.p","zwei.p.se",#
	"bzwei.x0","bzwei.x0.se","bzwei.x1","bzwei.x1.se","bzwei.z0","bzwei.z0.se","bzwei.z1","bzwei.z1.se","bzwei.z2","bzwei.z2.se","bzwei.p","bzwei.p.se",#
	"cox.x1.rmse",#
	"exp.x0.rmse","exp.x1.rmse","zexp.z0.rmse","zexp.z1.rmse","zexp.z2.rmse","zexp.x0.rmse","zexp.x1.rmse","bzexp.x0.rmse","bzexp.x1.rmse","bzexp.z0.rmse","bzexp.z1.rmse","bzexp.z2.rmse",#
	"wei.x0.rmse","wei.x1.rmse","wei.p.rmse","zwei.z0.rmse","zwei.z1.rmse","zwei.z2.rmse",#
	"zwei.x0.rmse","zwei.x1.rmse","zwei.p.rmse", "bzwei.x0.rmse","bzwei.x1.rmse","bzwei.z0.rmse","bzwei.z1.rmse","bzwei.z2.rmse","bzwei.p.rmse",#
	"cox.x1.cp","exp.x0.cp","exp.x1.cp","zexp.z0.cp","zexp.z1.cp","zexp.z2.cp","zexp.x0.cp","zexp.x1.cp","bzexp.x0.cp","bzexp.x1.cp","bzexp.z0.cp","bzexp.z1.cp","bzexp.z2.cp",#
	"wei.x0.cp","wei.x1.cp","wei.p.cp",#
	"zwei.z0.cp","zwei.z1.cp","zwei.z2.cp","zwei.x0.cp","zwei.x1.cp","zwei.p.cp", "bzwei.x0.cp","bzwei.x1.cp","bzwei.z0.cp","bzwei.z1.cp","bzwei.z2.cp","bzwei.p.cp")#
#save dataset#
main.data2<-as.data.frame(main.data)#
write.dta(main.data2,"main.data2.dta", )
